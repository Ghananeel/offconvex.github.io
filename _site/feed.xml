<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Off the convex path</title>
    <description>Algorithms off the convex path.</description>
    <link>http://offconvex.github.io/</link>
    <atom:link href="http://offconvex.github.io/feed.xml" rel="self" type="application/rss+xml" />
    
     
      <item>
        <title>How to Escape Saddle Points Efficiently</title>
        <description>&lt;p&gt;A core, emerging problem in nonconvex optimization involves the escape of saddlepoints.  While recent research has shown that gradient descent (GD) generically escapes saddle points asymptotically (see &lt;a href=&quot;http://www.offconvex.org/2016/03/22/saddlepoints/&quot;&gt;Rong Ge’s&lt;/a&gt; and &lt;a href=&quot;http://www.offconvex.org/2016/03/24/saddles-again/&quot;&gt;Ben Recht’s&lt;/a&gt; blog posts), the critical open problem is one of &lt;strong&gt;efficiency&lt;/strong&gt; — is GD able to move past saddle points quickly, or can it be slowed down significantly?  How does the rate of escape scale with the ambient dimensionality?  In this post, we describe &lt;a href=&quot;https://arxiv.org/abs/1703.00887&quot;&gt;our recent work with Rong Ge, Praneeth Netrapalli and Sham Kakade&lt;/a&gt;, that provides the first provable &lt;em&gt;positive&lt;/em&gt; answer to the efficiency question, showing that, rather surprisingly, GD augmented with suitable perturbations escapes saddle points efficiently; indeed, in terms of rate and dimension dependence it is almost as if the saddle points aren’t there!&lt;/p&gt;

&lt;h2 id=&quot;perturbing-gradient-descent&quot;&gt;Perturbing Gradient Descent&lt;/h2&gt;
&lt;p&gt;We are in the realm of classical gradient descent (GD) — given a function $f:\mathbb{R}^d \to \mathbb{R}$ we aim to minimize the function by moving in the direction of the negative gradient:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;x_{t+1} = x_t - \eta \nabla f(x_t),&lt;/script&gt;

&lt;p&gt;where $x_t$ are the iterates and $\eta$ is the step size. GD is well understood theorietically in the case of convex optimization, but the general case of nonconvex optimization has been far less studied. We know that GD converges quickly to the neighborhood of stationary points (points where $\nabla f(x) = 0$) in the nonconvex setting, but these stationary points may be local minima or, unhelpfully, local maxima or saddle points.&lt;/p&gt;

&lt;p&gt;Clearly GD will never move away from a stationary point if started there (even a local maximum); thus, to provide general guarantees, it is necessary to modify GD slightly to incorporate some degree of randomness. Two simple methods have been studied in the literature:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Intermittent Perturbations&lt;/strong&gt;: &lt;a href=&quot;http://arxiv.org/abs/1503.02101&quot;&gt;Ge, Huang, Jin and Yuan 2015&lt;/a&gt; considered adding occasional random perturbations to GD, and were able to provide the first &lt;em&gt;polynomial time&lt;/em&gt; guarantee for GD to escape saddle points.  (See also &lt;a href=&quot;http://www.offconvex.org/2016/03/22/saddlepoints/&quot;&gt;Rong Ge’s post&lt;/a&gt; )&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Random Initialization&lt;/strong&gt;: &lt;a href=&quot;http://arxiv.org/abs/1602.04915&quot;&gt;Lee et al. 2016&lt;/a&gt; showed that with only random initialization, GD provably avoids saddle points asymptotically (i.e., as the number of steps goes to infinity). (see also &lt;a href=&quot;http://www.offconvex.org/2016/03/24/saddles-again/&quot;&gt;Ben Recht’s post&lt;/a&gt;)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Asymptotic — and even polynomial time —results are important for the general theory, but they stop short of explaining the success of gradient-based algorithms in practical nonconvex problems.  And they fail to provide reassurance that at least some of time, GD will not succeed — that the learning curve may flatten out for an indefinite amount of time, and the user will not know that the asymptotics have not kicked in. Lastly, they fail to provide reassurance that GD has the kind of favorable properties in high dimensions that it is known to have for convex problems.&lt;/p&gt;

&lt;p&gt;One reasonable approach to this issue is to consider second-order (Hessian-based) algorithms.  Although these algorithms are generally (far) more expensive per iteration than GD, and can be more complicated to implement, they do provide the kind of geometric information around saddle points that allows for efficient escape. Accordingly, a reasonable understanding of Hessian-based algorithms has emerged in the literature, and positive efficiency results have been obtained.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Is GD also efficient? Or is the Hessian necessary for fast escape of saddle points?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A negative result emerges to this first question if one considers the random initialization strategy discussed. Indeed, this approach is provably &lt;em&gt;inefficient&lt;/em&gt; in general, taking exponential time to escape saddle points in the worst case (see “On the Necessity of Adding Perturbations” section).&lt;/p&gt;

&lt;p&gt;Somewhat surprisingly, it turns out that we obtain a rather different — and &lt;em&gt;positive&lt;/em&gt; — result if we consider the perturbation strategy.  To be able to state this result, let us be clear on the algorithm that we analyze:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Perturbed gradient descent (PGD)&lt;/strong&gt;&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;strong&gt;for&lt;/strong&gt; $~t = 1, 2, \ldots ~$ &lt;strong&gt;do&lt;/strong&gt;&lt;/li&gt;
    &lt;li&gt;$\quad\quad x_{t} \leftarrow x_{t-1} - \eta \nabla f (x_{t-1})$&lt;/li&gt;
    &lt;li&gt;$\quad\quad$ &lt;strong&gt;if&lt;/strong&gt; $~$&lt;em&gt;perturbation condition holds&lt;/em&gt;$~$ &lt;strong&gt;then&lt;/strong&gt;&lt;/li&gt;
    &lt;li&gt;$\quad\quad\quad\quad x_t \leftarrow x_t + \xi_t$&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;Here the perturbation $\xi_t$ is sampled uniformly from a ball centered at zero with a suitably small radius, and is added to the iterate when the gradient is suitably small. These particular choices are made for analytic convenience; we do not believe that uniform noise is necessary. nor do we believe it essential that noise be added only when the gradient is small.&lt;/p&gt;

&lt;h2 id=&quot;strict-saddle-and-second-order-stationary-points&quot;&gt;Strict-Saddle and Second-order Stationary Points&lt;/h2&gt;
&lt;p&gt;We define &lt;em&gt;saddle points&lt;/em&gt; in this post to include both classical saddle points as well as local maxima.  They are stationary points which are locally maximized along &lt;em&gt;at least one direction&lt;/em&gt;.  Saddle points and local minima can be categorized according to the minimum eigenvalue of Hessian:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\lambda_{\min}(\nabla^2 f(x))  \begin{cases}
                        &gt; 0 \quad\quad  \text{local minimum} \\
                        = 0 \quad\quad  \text{local minimum or saddle point} \\
                        &lt; 0 \quad\quad  \text{saddle point}
                    \end{cases} %]]&gt;&lt;/script&gt;

&lt;p&gt;We further call the saddle points in the last category, where $\lambda_{\min}(\nabla^2 f(x)) &amp;lt; 0$, &lt;strong&gt;strict saddle points&lt;/strong&gt;.&lt;/p&gt;

&lt;p style=&quot;text-align:center;&quot;&gt;
&lt;img src=&quot;/assets/saddle_eff/strictsaddle.png&quot; width=&quot;85%&quot; alt=&quot;Strict and Non-strict Saddle Point&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;While non-strict saddle points can be flat in the valley, strict saddle points requires there &lt;em&gt;at least one direction&lt;/em&gt; where the curvature is strictly negative. The presence of such a direction allows the possibility of a gradient-based algorithm to escape the saddle point.  In general, distinguishing local minima and non-strict saddle points is &lt;em&gt;NP-hard&lt;/em&gt;; therefore, we — and previous authors — focus on escaping &lt;em&gt;strict&lt;/em&gt; saddle points.&lt;/p&gt;

&lt;p&gt;Formally, we make the following two standard assumptions regarding smoothness.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Assumption 1&lt;/strong&gt;: $f$ is $\ell$-gradient-Lipschitz, i.e. &lt;br /&gt;
$\quad\quad\quad\quad \forall x_1, x_2, |\nabla f(x_1) - \nabla f(x_2)| \le \ell |x_1 - x_2|$. &lt;br /&gt;
$~$&lt;br /&gt;
 &lt;strong&gt;Assumption 2&lt;/strong&gt;: $f$ is $\rho$-Hessian-Lipschitz, i.e. &lt;br /&gt;
$\quad\quad\quad\quad \forall x_1, x_2$, $|\nabla^2 f(x_1) - \nabla^2 f(x_2)| \le \rho |x_1 - x_2|$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Similarly to classical theory, which studies convergence to a first-order stationary point, $\nabla f(x) = 0$, by bounding the number of iterations to find a &lt;strong&gt;$\epsilon$-first-order stationary point&lt;/strong&gt;,  $|\nabla f(x)| \le \epsilon$, we formulate the speed of escape of strict saddle points and the ensuing convergence to a second-order stationary point, $\nabla f(x) = 0, \lambda_{\min}(\nabla^2 f(x)) \ge 0$, with an $\epsilon$-version of the definition:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Definition&lt;/strong&gt;: A point $x$ is &lt;strong&gt;$\epsilon$-second-order stationary point&lt;/strong&gt; if:&lt;br /&gt;
$\quad\quad\quad\quad |f(x)|\le \epsilon$, and $\lambda_{\min}(\nabla^2 f(x)) \ge -\sqrt{\rho \epsilon}$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In this definition, $\rho$ is the Hessian Lipschitz constant introduced above. This scaling follows the convention of &lt;a href=&quot;http://rd.springer.com/article/10.1007%2Fs10107-006-0706-8&quot;&gt;Nesterov and Polyak 2006&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;applications&quot;&gt;Applications&lt;/h3&gt;
&lt;p&gt;In a wide range of practical nonconvex problems it has been proved that &lt;strong&gt;all saddle points are strict&lt;/strong&gt; — such problems include, but not are limited to, principal components analysis, canonical correlation analysis, 
&lt;a href=&quot;http://arxiv.org/abs/1503.02101&quot;&gt;orthogonal tensor decomposition&lt;/a&gt;, 
&lt;a href=&quot;http://arxiv.org/abs/1602.06664&quot;&gt;phase retrieval&lt;/a&gt;,
&lt;a href=&quot;http://arxiv.org/abs/1504.06785&quot;&gt;dictionary learning&lt;/a&gt;,
&lt;!-- matrix factorization,  --&gt;
&lt;a href=&quot;http://arxiv.org/abs/1605.07221&quot;&gt;matrix sensing&lt;/a&gt;, 
&lt;a href=&quot;http://arxiv.org/abs/1605.07272&quot;&gt;matrix completion&lt;/a&gt;, 
and &lt;a href=&quot;http://arxiv.org/abs/1704.00708&quot;&gt;other nonconvex low rank problems&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Furthermore, in all of these nonconvex problems, it also turns out that &lt;strong&gt;all local minima are global minima&lt;/strong&gt;. Thus, in these cases, any general efficient algorithm for finding $\epsilon$-second-order stationary points immediately becomes an efficient algorithm for solving those nonconvex problem with global guarantees.&lt;/p&gt;

&lt;h2 id=&quot;escaping-saddle-point-with-negligible-overhead&quot;&gt;Escaping Saddle Point with Negligible Overhead&lt;/h2&gt;
&lt;p&gt;In the classical case of first-order stationary points, GD is known to have very favorable theoretical properties:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Theorem (&lt;a href=&quot;http://rd.springer.com/book/10.1007%2F978-1-4419-8853-9&quot;&gt;Nesterov 1998&lt;/a&gt;)&lt;/strong&gt;: If Assumption 1 holds, then GD with $\eta = 1/\ell$ finds an $\epsilon$-&lt;strong&gt;first&lt;/strong&gt;-order stationary point in $2\ell (f(x_0) - f^\star)/\epsilon^2$ iterations.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In this theorem, $x_0$ is the initial point and $f^\star$ is the function value of the global minimum. The theorem says for that any gradient-Lipschitz function, a stationary point can be found by GD in $O(1/\epsilon^2)$ steps, with no explicit dependence on $d$. This is called “dimension-free optimization” in the literature; of course the cost of a gradient computation is $O(d)$, and thus the overall runtime of GD scales as $O(d)$. The linear scaling in $d$ is especially important for modern high-dimensional nonconvex problems such as deep learning.&lt;/p&gt;

&lt;p&gt;We now wish to address the corresponding problem for second-order stationary points.
What is the best we can hope for? Can we also achieve&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;A dimension-free number of iterations;&lt;/li&gt;
  &lt;li&gt;An $O(1/\epsilon^2)$ convergence rate;&lt;/li&gt;
  &lt;li&gt;The same dependence on $\ell$ and $(f(x_0) - f^\star)$ as in (Nesterov 1998)?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Rather surprisingly, the answer is &lt;em&gt;Yes&lt;/em&gt; to all three questions (up to small log factors).&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Main Theorem&lt;/strong&gt;: If Assumptions 1 and 2 hold, then PGD, with $\eta = O(1/\ell)$ finds an $\epsilon$-&lt;strong&gt;second&lt;/strong&gt;-order stationary point in $\tilde{O}(\ell (f(x_0) - f^\star)/\epsilon^2)$ iterations with high probability.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Here $\tilde{O}(\cdot)$ hides only logarithmic factors; indeed, the dimension dependence in our result is only $\log^4(d)$. The theorem thus asserts that a perturbed form of GD, under an additional Hessian-Lipschitz condition, &lt;strong&gt;&lt;em&gt;converges to a second-order-stationary point in almost the same time required for GD to converge to a first-order-stationary point.&lt;/em&gt;&lt;/strong&gt; In this sense, we claim that PGD can escape strict saddle points almost for free.&lt;/p&gt;

&lt;p&gt;We turn to a discussion of some of the intuitions underlying these results.&lt;/p&gt;

&lt;h3 id=&quot;why-do-polylogd-iterations-suffice&quot;&gt;Why do polylog(d) iterations suffice?&lt;/h3&gt;
&lt;p&gt;Our strict-saddle assumption means that there is only, in the worst case, one direction in $d$ dimensions along which we can escape. A naive search for the descent direction intuitively should take at least $\text{poly}(d)$ iterations, so why should only $\text{polylog}(d)$ suffice?&lt;/p&gt;

&lt;p&gt;Consider a simple case in which we assume that the function is quadratic in the neighborhood of the saddle point.  That is, let the objective function be $f(x) = x^\top H x$, a saddle point at zero, with constant Hessian $H = \text{diag}(-1, 1, \cdots, 1)$. In this case, only the first direction is an escape direction (with negative eigenvalue $-1$).&lt;/p&gt;

&lt;p&gt;It is straightforward to work out the general form of the iterates in this case:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;x_t = x_{t-1} - \eta \nabla f(x_{t-1}) = (I - \eta H)x_{t-1} = (I - \eta H)^t x_0.&lt;/script&gt;

&lt;p&gt;Assume that we start at the saddle point at zero, then add a perturbation so that $x_0$ is sampled uniformly from a ball $\mathcal{B}_0(1)$ centered at zero with radius one.
The decrease in the function value can be expressed as:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;f(x_t) - f(0) = x_t^\top H x_t  = x_0^\top (I - \eta H)^t H (I - \eta H)^t x_0.&lt;/script&gt;

&lt;p&gt;Set the step size to be $1/2$, let $\lambda_i$ denote the $i$-th eigenvalue of the Hessian $H$ and let $\alpha_i = e_i^\top x_0$ denote the component in the $i$th direction of the initial point $x_0$. We have $\sum_{i=1}^d \alpha_i^2  = | x_0|^2 = 1$, thus:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;f(x_t) - f(0) = \sum_{i=1}^d \lambda_i (1-\eta\lambda_i)^{2t} \alpha_i^2 \le  -1.5^{2t} \alpha_1^2 + 0.5^{2t}.&lt;/script&gt;

&lt;p&gt;A simple probability argument shows that sampling uniformly in $\mathcal{B}_0(1)$ will result in at least a $\Omega(1/d)$ component in the first direction with high probability. That is, $\alpha^2_1 = \Omega(1/d)$. Substituting $\alpha_1$ in the above equation, we see that it takes at most $O(\log d)$ steps for the function value to decrease by a constant amount.&lt;/p&gt;

&lt;h3 id=&quot;pancake-shape-stuck-region-for-general-hessian&quot;&gt;Pancake-shape stuck region for general Hessian&lt;/h3&gt;
&lt;p&gt;We can conclude that for the case of a constant Hessian, only when the perturbation $x_0$ lands in the set $\{x | ~ |e_1^\top x|^2 \le O(1/d)\}$ $\cap \mathcal{B}_0 (1)$, can we take a very long time to escape the saddle point. We call this set the &lt;strong&gt;stuck region&lt;/strong&gt;; in this case it is a flat disk. In general, when the Hessian is no longer constant, the stuck region becomes a non-flat pancake, depicted as a green object in the left graph. In general this region will not have an analytic expression.&lt;/p&gt;

&lt;p&gt;Earlier attempts to analyze the dynamics around saddle points tried to the approximate stuck region by a flat set.  This results in a requirement of an extremely small step size and a correspondingly very large runtime complexity.  Our sharp rate depends on a key observation — &lt;em&gt;although we don’t know the shape of the stuck region, we know it is very thin&lt;/em&gt;.&lt;/p&gt;

&lt;p style=&quot;text-align:center;&quot;&gt;
&lt;img src=&quot;/assets/saddle_eff/flow.png&quot; width=&quot;85%&quot; alt=&quot;Pancake&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;In order to characterize the “thinness” of this pancake, we studied pairs of hypothetical perturbation points $w, u$ separated by $O(1/\sqrt{d})$ along an escaping direction. We claim that if we run GD starting at $w$ and $u$, at least one of the resulting trajectories will escape the saddle point very quickly. This implies that the thickness of the stuck region can be at most $O(1/\sqrt{d})$, so a random perturbation has very little chance to land in the stuck region.&lt;/p&gt;

&lt;h2 id=&quot;on-the-necessity-of-adding-perturbations&quot;&gt;On the Necessity of Adding Perturbations&lt;/h2&gt;
&lt;p&gt;We have discussed two possible ways to modify the standard gradient descent algorithm, the first by adding intermittent perturbations, and the second by relying on random initialization. Although the latter exhibits asymptotic convergence, it does not yield efficient convergence in general; in recent &lt;a href=&quot;http://arxiv.org/abs/1705.10412&quot;&gt;joint work with Simon Du, Jason Lee, Barnabas Poczos, and Aarti Singh&lt;/a&gt;, we have shown that even with fairly natural random initialization schemes and non-pathological functions, &lt;strong&gt;GD with only random initialization can be significantly slowed by saddle points, taking exponential time to escape. The behavior of PGD is strikingingly different — it can generically escape saddle points in polynomial time.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;To establish this result, we considered random initializations from a very general class including Gaussians and uniform distributions over the hypercube, and we constructed a smooth objective function that satisfies both Assumptions 1 and 2. This function is constructed such that, even with random initialization, with high probability both GD and PGD have to travel sequentially in the vicinity of $d$ strict saddle points before reaching a local minimum. All strict saddle points have only one direction of escape. (See the left graph for the case of $d=2$).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/saddle_eff/necesperturbation.png&quot; alt=&quot;NecessityPerturbation&quot; /&gt;&lt;/p&gt;

&lt;p&gt;When GD travels in the vicinity of a sequence of saddle points, it can get closer and closer to the later saddle points, and thereby take longer and longer to escape. Indeed, the time to escape the $i$th saddle point scales as $e^{i}$. On the other hand, PGD is always able to escape any saddle point in a small number of steps independent of the history. This phenomenon is confirmed by our experiments; see, for example, an experiment with $d=10$ in the right graph.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;In this post, we have shown that a perturbed form of gradient descent can converge to a second-order-stationary point at almost the same rate as standard gradient descent converges to a first-order-stationary point. This implies that Hessian information is not necessary for to escape saddle points efficiently, and helps to explain why basic gradient-based algorithms such as GD (and SGD) work surprisingly well in the nonconvex setting. This new line of sharp convergence results can be directly applied to nonconvex problem such as matrix sensing/completion to establish efficient global convergence rates.&lt;/p&gt;

&lt;p&gt;There are of course still many open problems in general nonconvex optimization. To name a few: will adding momentum improve the convergence rate to a second-order stationary point? What type of local minima are tractable and are there useful structural assumptions that we can impose on local minima so as to avoid local minima efficiently? We are making slow but steady progress on nonconvex optimization, and there is the hope that at some point we will transition from “black art” to “science”.&lt;/p&gt;

</description>
        <pubDate>Wed, 19 Jul 2017 03:00:00 -0700</pubDate>
        <link>http://offconvex.github.io/2017/07/19/saddle-efficiency/</link>
        <guid isPermaLink="true">http://offconvex.github.io/2017/07/19/saddle-efficiency/</guid>
      </item>
     
    
     
      <item>
        <title>Do GANs actually do distribution learning?</title>
        <description>&lt;p&gt;This post is about our new paper, which presents empirical evidence that current GANs (Generative Adversarial Nets) are quite far from learning the target distribution. Previous posts had &lt;a href=&quot;http://www.offconvex.org/2017/03/15/GANs/&quot;&gt;introduced GANs&lt;/a&gt; and described &lt;a href=&quot;http://www.offconvex.org/2017/03/30/GANs2/&quot;&gt;new theoretical analysis of GANs&lt;/a&gt; from &lt;a href=&quot;https://arxiv.org/abs/1703.00573&quot;&gt;our ICML17 paper&lt;/a&gt;. One notable implication of our theoretical analysis was that when the discriminator size is bounded, then  GANs  training could appear to succeed (i.e., training objective reaches its optimum value) even if the generated distribution is discrete and has very low support —-in other words, the training objective is unable to prevent even extreme &lt;em&gt;mode collapse&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;That paper led us (especially Sanjeev) into spirited discussions with colleagues, who wondered if this is &lt;em&gt;just&lt;/em&gt; a theoretical result about potential misbehavior rather than a prediction about  real-life training.  After all, we’ve all seen the great pictures that GANs produce in real life, right? (Note that the theoretical result only describes a possible near-equilibrium that can arise with a certain mix of hyperparameters, and conceivably real-life training avoids that by suitable hyperparameter tuning.)&lt;/p&gt;

&lt;p&gt;Our new empirical paper &lt;a href=&quot;https://arxiv.org/abs/1706.08224v1&quot;&gt;Do GANs actually learn the distribution? An empirical study&lt;/a&gt; puts the issue to the test. We present empirical evidence that well-known GANs approaches do end up learning distributions of fairly low support, and thus presumably are not learning the target distribution.&lt;/p&gt;

&lt;p&gt;Let’s start by imagining how large the support must be for the target distribution. For example, if the distribution is the set of all possible images of human faces (real or imagined), then these must involve all combinations of hair color/style, facial features, complexion, expression, pose, lighting, race, etc., and thus the possible set of images of faces that &lt;em&gt;humans will consider to be distinct&lt;/em&gt; approaches infinity. (After all, there are billions of distinct people living on earth right now.)
GANs are trying to learn this full distribution using a finite sample of images, say &lt;a href=&quot;http://mmlab.ie.cuhk.edu.hk/projects/CelebA.html&quot;&gt;CelebA&lt;/a&gt; which has $200,000$ images of celebrity faces.&lt;/p&gt;

&lt;p&gt;Thus a simple sanity check for whether a GAN has truly come close to learning this distribution is to estimate how many “distinct” images it can produce. At first glance, such an estimation seems very difficult. After all, automated/heuristic measures of image similarity can be easily fooled, and we humans surely don’t have enough time to go through millions or billions of images, right?&lt;/p&gt;

&lt;p&gt;Luckily, a crude estimate is possible using the simple birthday paradox, a staple of undergrad discrete math.&lt;/p&gt;

&lt;h2 id=&quot;birthday-paradox-test-for-size-of-the-support&quot;&gt;Birthday paradox test for size of the support&lt;/h2&gt;

&lt;p&gt;Imagine for argument’s sake that the human race were limited to a genetic diversity of a million —nature’s laws only allow this many distinct humans. How would this hard limit manifest itself in our day to day life? The birthday paradox says that if we take a random sample of a thousand people —note that most of us get to know this many people easily in our lifetimes—we’d see many &lt;a href=&quot;https://en.wikipedia.org/wiki/Doppelg%C3%A4nger_&quot;&gt;doppelgangers&lt;/a&gt;. Of course, in practice the only doppelgangers we encounter happen to be identical twins.&lt;/p&gt;

&lt;p&gt;Formally, the birthday paradox says that if a discrete distribution has support $N$, then  a random sample of size about
$\sqrt{N}$ would be quite likely to contain a duplicate.   (The name comes from its implication that if you put $23 \approx \sqrt{365}$ random people in a room, the chance that two of them have the same birthday is about $1/2$.)&lt;/p&gt;

&lt;p&gt;In the GAN setting, the distribution is continuous, not discrete. Thus our proposed birthday paradox test for GANs is as follows.&lt;/p&gt;

&lt;p&gt;(a) Pick a sample of size $s$ from the generated distribution. (b) Use an automated measure of image similarity to flag the $20$ (say) most similar pairs in the sample. (c) Visually inspect the flagged pairs and check for images that a human would consider near-duplicates. (d) Repeat.&lt;/p&gt;

&lt;p&gt;If this test reveals that samples of size $s$ have duplicate images with good probability,  then suspect that the distribution has support size about $s^2$.&lt;/p&gt;

&lt;p&gt;Note that the test is not definitive, because the distribution could assign say a probability $10\%$ to a single image, and be uniform on a huge number of other images. Then the test would be quite likely to find a duplicate even with $20$ samples, even though the true support size is huge. But such nonuniformity (a lot of probability being assigned to a few images) is the only failure mode of the birthday paradox test calculation, and such nonuniformity would itself be considered a failure mode of GANs training. The CIFAR-10 samples below show that such nonuniformality can be severe in practice, where the generator tends to generate a fixed image of automobile very likely. On CIFAR-10, this failure mode is also observed in classes of frogs and cats.&lt;/p&gt;

&lt;h2 id=&quot;experimental-results&quot;&gt;Experimental results.&lt;/h2&gt;

&lt;p&gt;Our test was done using two datasets, CelebA (faces) and CIFAR-10.&lt;/p&gt;

&lt;p&gt;For faces,  we found Euclidean distance in pixel space works well as a heuristic similarity measure, probably because the samples are centered and aligned. For CIFAR-10, we pre-train a discriminative Convolutional Neural Net for the full classification problem, and use the top layer representation as an embedding of the image. Heuristic similarity is then measured as the Euclidean distance in the embedding space. Possibly these similarity measures are crude, but note that improving them can only &lt;em&gt;lower&lt;/em&gt; our estimate of the support size of the distribution, since  a better similarity measure can only increase the number of duplicates found. Thus our estimates below should be considered as upper bounds on the support size of the distribution.&lt;/p&gt;

&lt;h2 id=&quot;results--on-celeba-dataset&quot;&gt;Results  on CelebA dataset&lt;/h2&gt;
&lt;p&gt;We tested the following methods, doing the birthday paradox test  with Euclidean distance in pixel space as the heuristic similarity measure.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DCGAN —unconditional as described in &lt;a href=&quot;https://arxiv.org/abs/1406.2661&quot;&gt;Goodfellow et al. 2014&lt;/a&gt; and &lt;a href=&quot;https://arxiv.org/abs/1511.06434&quot;&gt;Radford et al. 2015&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;MIX+GAN  protocol introduced in &lt;a href=&quot;https://arxiv.org/abs/1703.00573&quot;&gt;Arora et al.&lt;/a&gt;, specifically, MIX+DCGAN with $3$ mixture components.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1606.00704&quot;&gt;Adversarily Learned Inference (ALI)&lt;/a&gt; (or equivalently &lt;a href=&quot;https://arxiv.org/abs/1605.09782&quot;&gt;BiGANs&lt;/a&gt;). (ALI is probabilistic version of BiGANs, but their architectures are equivalent. So we only tested ALI in our experiments.)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We find that with probability $\geq50\%$, a batch of about $400$ samples contains at least one pair of duplicates for both DCGAN and MIX+DCGAN. The figure below give examples duplicates and their nearest neighbors samples (that we could fine) in training set. These results suggest that the support size of the distribution is less than $400^2\approx160000$, which is actually lower than the diversity of the training set, but this distribution is not just memorizing the training set.&lt;/p&gt;

&lt;p&gt;ALI (or BiGANs) appear to be somewhat more diverse, in that collisions appear with $50\%$ probability only with a batch size of $1000$, implying a support size of a million. This is $5$x the training set, but still much smaller than the diversity one would expect among human faces (After all doppelgangers don’t appear in samples of a few thousand people in real life.) For fair comparison, we set the discriminator of ALI (or BiGANs) to be roughly the same in size as that of the DCGAN model, since the results below suggests that the discriminator size has a strong effect on diversity of the learnt distribution.) Nevertheless, these tests do support the suggestion that the bidirectional structure prevents some of the mode collapses observed in usual GANs.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/7v2qbs4i82cczsy/similar_face_pairs.png?dl=1&quot; alt=&quot;similar_face_pairs&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;diversity-vs-discriminator-size&quot;&gt;Diversity vs Discriminator Size&lt;/h2&gt;

&lt;p&gt;The analysis of &lt;a href=&quot;https://arxiv.org/abs/1703.00573&quot;&gt;Arora et al.&lt;/a&gt; suggested that the support size could be as low as near-linear in the capacity of the discriminator; in other words, there is a near-equilibrium in which a distribution of such a small support could suffice to fool the best discriminator. So it is worth investigating whether training in real life allows generator nets to exploit this “loophole” in the training that we now know is in principle available to them.&lt;/p&gt;

&lt;p&gt;We built DCGANs with increasingly larger discriminators while fixing the other hyper-parameters. The discriminator used here is a 5-layer Convolutional Neural Network such that the number of output channels of each layer is $1\times,2\times,4\times,8\times\textit{dim}$ where $dim$ is chosen to be $16,32,48,64,80,96,112,128$. Thus the discriminator size  should be proportional to $dim^2$. The figure below suggests that in this simple setup the diversity of the learnt distribution does indeed grow near-linearly with the discriminator size. (Note the diversity is seen to plateau, possibly because one needs to change other parameters like depth to meaningfully add more capacity to the discriminator.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/zmhprwu2w2rddep/diversity_vs_size.png?dl=1&quot; alt=&quot;diversity_vs_size&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;results-for-cifar-10&quot;&gt;Results for CIFAR-10&lt;/h2&gt;

&lt;p&gt;On CIFAR-10, as mentioned earlier, we use a heuristic image similarity computed with convolutional neural net with 3 convolutional layers, 2 fully-connected layer and a 10-class soft-max output pretrained with a multi-class classification objective. Specifically, the  top layer features are viewed as embeddings for similarity test using Euclidean distance. 
We found that this heuristic similarity test quickly becomes useless if the samples display noise artifacts, and thus was effective only on the very best GANs that generate the most real-looking images. For CIFAR-10
this led us to &lt;a href=&quot;https://arxiv.org/abs/1612.04357&quot;&gt;Stacked GAN&lt;/a&gt;, currently believed to be the best generative model on CIFAR-10 (Inception Score $8.59$). Since this model is trained by conditioning on class label, we measure its diversity within each class separately.&lt;/p&gt;

&lt;p&gt;The training set for each class has $10k$ images, but since the generator is allowed to learn from all classes, presumably it can mix and match (especially background, lighting, landscape etc.) between classes and learn a fairly rich set of images.&lt;/p&gt;

&lt;p&gt;Now we list the batch sizes needed for duplicates to appear.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/bumdhzlcrk1z97b/cifar_diversity_table.png?dl=1&quot; alt=&quot;cifar_diversity_table&quot; /&gt;&lt;/p&gt;

&lt;p&gt;As before, we show duplicate samples as well as the nearest neighbor to the samples in training set (identified by using heuristic similarity measure to flag possibilities and confirming visually).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/8itrpjngrc13eam/selected_similar_cifar_samples.png?dl=1&quot; alt=&quot;similar_cifar_samples&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We find that the closest image is quite different from the duplicate detected, which suggests the issue with GANs is indeed lack of diversity (low support size) instead of memorizing training set. (See &lt;a href=&quot;https://arxiv.org/abs/1706.08224v1&quot;&gt;the paper&lt;/a&gt; for more examples.)&lt;/p&gt;

&lt;p&gt;Note that by and large the diversity of the learnt distribution is higher than that of the training set, but still not as high as one would expect in terms of all possible combinations.&lt;/p&gt;

&lt;h1 id=&quot;birthday-paradox-test-for-vaes&quot;&gt;Birthday paradox test for VAEs&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/p1qlgr66rnufnal/vae_collisions.png?dl=1&quot; alt=&quot;vae_collisions&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Given these findings, it is natural to wonder about the diversity of distributions learned using earlier methods such as &lt;a href=&quot;https://arxiv.org/abs/1312.6114&quot;&gt;Variational Auto-Encoders&lt;/a&gt; (VAEs). Instead of using feedback from the discriminator, these methods train the generator net using feedback from an approximate perplexity calculation. Thus the analysis of &lt;a href=&quot;https://arxiv.org/abs/1703.00573&quot;&gt;Arora et al.&lt;/a&gt; does not apply as is to such methods and it is conceivable they exhibit higher diversity. However, we found the birthday paradox test difficult to run since samples from a VAE trained on CelebA were not realistic or sharp enough for a human to definitively conclude whether or not two images were almost the same. The figure above shows examples of collision candidates found in batches of 400 samples; clearly some indicative parts (hair, eyes, mouth, etc.) are quite blurry in VAE samples.&lt;/p&gt;

&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;Our new birthday paradox test seems to suggest that some well-regarded GANs are currently learning distributions that with rather low support (i.e., suffer mode collapse). The possibility of such a scenario was anticipated in the theoretical analysis of (&lt;a href=&quot;https://arxiv.org/abs/1703.00573&quot;&gt;Arora et al.&lt;/a&gt;) reported in an earlier post.&lt;/p&gt;

&lt;p&gt;This combination of theory and empirics raises the open problem of how to change the GANs training to avoid such mode collapse. Possibly  ALI/BiGANs point to the right direction, since they exhibit somewhat better diversity  in our experiments. One should also try tuning of hyperparameter/architecture in current methods  now that the birthday paradox test gives a concrete way to quantify mode collapse.&lt;/p&gt;

&lt;p&gt;Finally, we should consider the possibility that the best use of GANs and related techniques could be feature learning or some other goal, as opposed to distribution learning. This needs further theoretical and empirical exploration.&lt;/p&gt;
</description>
        <pubDate>Thu, 06 Jul 2017 23:00:00 -0700</pubDate>
        <link>http://offconvex.github.io/2017/07/06/GANs3/</link>
        <guid isPermaLink="true">http://offconvex.github.io/2017/07/06/GANs3/</guid>
      </item>
     
    
     
      <item>
        <title>Unsupervised learning, one notion or many?</title>
        <description>&lt;p&gt;&lt;em&gt;Unsupervised learning&lt;/em&gt;, as the name suggests, is the science of learning from unlabeled data. A look at the &lt;a href=&quot;https://en.wikipedia.org/wiki/Unsupervised_learning&quot;&gt;wikipedia page&lt;/a&gt; shows that this term has many interpretations:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(Task A)&lt;/strong&gt;  &lt;em&gt;Learning a distribution from samples.&lt;/em&gt; (Examples: gaussian mixtures, topic models, variational autoencoders,..)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(Task B)&lt;/strong&gt; &lt;em&gt;Understanding latent structure in the data.&lt;/em&gt; This is not the same as (a); for example  principal component analysis, clustering, manifold learning etc. identify latent structure but don’t learn a distribution per se.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(Task C)&lt;/strong&gt; &lt;em&gt;Feature Learning.&lt;/em&gt; Learn a mapping from &lt;em&gt;datapoint&lt;/em&gt; $\rightarrow$ &lt;em&gt;feature vector&lt;/em&gt; such that classification tasks are easier to carry out on feature vectors rather than datapoints. For example, unsupervised feature learning could help lower the amount of &lt;em&gt;labeled&lt;/em&gt; samples needed for learning a classifier, or  be useful for &lt;a href=&quot;https://en.wikipedia.org/wiki/Domain_adaptation&quot;&gt;&lt;em&gt;domain adaptation&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Task B is often a subcase of Task C, as the intended user of “structure found in data” are humans (scientists) who  pour over the representation of data to gain some intuition about its properties, and these “properties” can be often phrased as a classification task.&lt;/p&gt;

&lt;p&gt;This post explains the relationship between  Tasks A and C, and why they get mixed up in students’ mind. We hope  there is also some food for thought here for experts, namely, our discussion about the fragility of the usual “perplexity” definition of unsupervised learning. It explains why Task A doesn’t in practice lead to good enough solution for Task C. For example, it has been believed for many years that for deep learning, unsupervised pretraining should help supervised training, but this has been hard to show in practice.&lt;/p&gt;

&lt;h2 id=&quot;the-common-theme-high-level-representations&quot;&gt;The common theme: high level representations.&lt;/h2&gt;

&lt;p&gt;If $x$ is a datapoint, each of these methods seeks to map it to a new “high level” representation $h$ that captures its “essence.”
This is why it helps to have access to $h$ when performing machine learning tasks on $x$ (e.g. classification). 
The difficulty of course is that  “high-level representation” is not uniquely defined. For example, $x$ may be an image, and $h$ may  contain the information that it contains a person and a dog. But another  $h$ may say that it shows a poodle and a person wearing pyjamas standing on the beach. This nonuniqueness seems inherent.&lt;/p&gt;

&lt;p&gt;Unsupervised learning tries to learn high-level representation using unlabeled data.
Each method make an implicit assumption about how the hidden $h$ relates to the visible $x$. For example, in k-means clustering the hidden $h$ consists of  labeling the datapoint with the index of the cluster it belongs to. 
Clearly, such a simple clustering-based representation has rather limited  expressive power since it groups datapoints into disjoint classes: this limits its application for complicated settings. For example, if one clusters images according to the labels “human”, “animal” “plant” etc., then which cluster should contain an image showing a man and a dog standing in front of a tree?&lt;/p&gt;

&lt;p&gt;The search for a descriptive language for talking about the possible relationships of representations and data leads us naturally to Bayesian models. (Note that these are viewed with some skepticism in  machine learning theory – compared to assumptionless models like PAC learning, online learning, etc. – but we do not know of another suitable vocabulary in this setting.)&lt;/p&gt;

&lt;h2 id=&quot;a-bayesian-view&quot;&gt;A Bayesian view&lt;/h2&gt;

&lt;p&gt;Bayesian approaches  capture the relationship between the “high level”  representation $h$ and the datapoint $x$ by postulating a &lt;em&gt;joint distribution&lt;/em&gt;  $p_{\theta}(x, h)$ of the data $x$ and representation $h$, such that $p_{\theta}(h)$ and the posterior $p_{\theta}(x \mid h)$ have a simple form as a function of the parameters $\theta$. These are also called &lt;em&gt;latent variable&lt;/em&gt; probabilistic models, since $h$ is a latent (hidden) variable.&lt;/p&gt;

&lt;p&gt;The standard goal in distribution learning is to find the $\theta$ that “best explains” the data (what we called Task (A)) above). This is formalized using maximum-likelihood estimation going back to Fisher (~1910-1920): find the $\theta$ that maximizes the &lt;em&gt;log probability&lt;/em&gt; of the training data. Mathematically, indexing the samples with $t$, we can write this as&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\max_{\theta} \sum_{t} \log p_{\theta}(x_t)  \qquad (1)&lt;/script&gt;

&lt;p&gt;where
&lt;script type=&quot;math/tex&quot;&gt;p_{\theta}(x_t) = \sum_{h_t}p_{\theta}(x_t, h_t).&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;(Note that $\sum_{t} \log p_{\theta}(x_t)$ is also the empirical estimate of the &lt;em&gt;cross-entropy&lt;/em&gt; 
$E_{x}[\log p_{\theta}(x)]$ of the distribution $p_{\theta}$, where $x$ is distributed according to $p^*$, the true distribution of the data. Thus the above method looks for the distribution with best cross-entropy on the empirical data, which is also log of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Perplexity&quot;&gt;&lt;em&gt;perplexity&lt;/em&gt;&lt;/a&gt; of $p_{\theta}$.)&lt;/p&gt;

&lt;p&gt;In the limit of $t \to ∞$, this estimator is &lt;em&gt;consistent&lt;/em&gt; (converges in probability to the ground-truth value) and &lt;em&gt;efficient&lt;/em&gt; (has lowest asymptotic mean-square-error among all consistent estimators). See the &lt;a href=&quot;https://en.wikipedia.org/wiki/Maximum_likelihood_estimation&quot;&gt;Wikipedia page&lt;/a&gt;. (Aside: maximum likelihood estimation is often NP-hard, which is one of the reasons for the renaissance of the method-of-moments and tensor decomposition algorithms in learning latent variable models, which &lt;a href=&quot;http://www.offconvex.org/2015/12/17/tensor-decompositions/&quot;&gt;Rong  wrote about some time ago&lt;/a&gt;.)&lt;/p&gt;

&lt;h3 id=&quot;toward-task-c-representations-arise-from-the-posterior-distribution&quot;&gt;Toward task C: Representations arise from the posterior distribution&lt;/h3&gt;

&lt;p&gt;Simply learning the distribution $p_{\theta}(x, h)$ does not yield a representation &lt;em&gt;per se.&lt;/em&gt; To get a distribution of $x$, we need access to the posterior $p_{\theta}(h \mid x)$: then a sample from this posterior can be used as a “representation” of a data-point $x$. (Aside: Sometimes, in settings when $p_{\theta}(h \mid x)$ has a simple description, this description can be viewed as the representation of $x$.)&lt;/p&gt;

&lt;p&gt;Thus solving Task C requires learning distribution parameters $\theta$  &lt;em&gt;and&lt;/em&gt; figuring out how to efficiently sample from the posterior distribution.&lt;/p&gt;

&lt;p&gt;Note that the sampling problems for the posterior can be #-P hard for very simple families. The reason is that by Bayes law, $p_{\theta}(h \mid x) = \frac{p_{\theta}(h) p_{\theta}(x \mid h)}{p_{\theta}(x)}$. Even if the numerator is  easy to calculate, as is the case for simple families, the   $p_{\theta}(x)$ involves a big summation (or integral) and is often hard to calculate.&lt;/p&gt;

&lt;p&gt;Note that the  max-likelihood parameter estimation (Task A) and approximating the posterior distributions $p(h \mid x)$ (Task C) can have radically different complexities: Sometimes A is easy but C is NP-hard (example: topic modeling with “nice” topic-word matrices, but short documents, see also &lt;a href=&quot;https://arxiv.org/abs/1411.6156&quot;&gt;Bresler 2015&lt;/a&gt;); or vice versa (example: topic modeling with long documents, but worst-case chosen topic matrices &lt;a href=&quot;https://arxiv.org/abs/1111.0952&quot;&gt;Arora et al. 2011&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;Of course, one may hope (as usual) that computational complexity is a worst-case notion and may not apply in practice. But there is a bigger issue with this setup, having to do with accuracy.&lt;/p&gt;

&lt;h2 id=&quot;why-the-above-reasoning-is-fragile-need-for-high-accuracy&quot;&gt;Why the above reasoning is fragile: Need for high accuracy&lt;/h2&gt;

&lt;p&gt;The above description assumes that the parametric model $p_{\theta}(x, h)$ for the data was &lt;em&gt;exact&lt;/em&gt; whereas one imagines it is only &lt;em&gt;approximate&lt;/em&gt; (i.e., suffers from modeling error). Furthermore, computational difficulties may restrict us to use approximately correct inference  even if the model were exact. So in practice, we may only have an &lt;em&gt;approximation&lt;/em&gt; $q(h|x)$ to 
the posterior distribution  $p_{\theta}(h \mid x)$. (Below we describe a popular methods to compute such approximations.)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;How good of an approximation&lt;/em&gt; to the true posterior do we need?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Recall, we are trying to answer this question through the lens of Task C, solving some classification task. We take the following point of view:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;For $t=1, 2,\ldots,$ nature picked some $(h_t, x_t)$ from the joint distribution  and presented us $x_t$. The true label $y_t$ of $x_t$ is $\mathcal{C}(h_t)$ where  $\mathcal{C}$ is an unknown classifier. Our goal is classify according to these labels.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To simplify notation, assume the output of $\mathcal{C}$ is binary. If we wish to use 
 $q(h \mid x)$ as a surrogate for the true posterior $p_{\theta}(h \mid x)$, we need to have 
 $\Pr_{x_t, h_t \sim q(\cdot \mid x_t)} [\mathcal{C}(h_t) \neq y_t]$ is small as well.&lt;/p&gt;

&lt;p&gt;How close must $q(h \mid x)$ and $p(h \mid x)$ be to let us conclude this? We will use KL divergence as “distance” between the distributions, for reasons that will become apparent in the following section. We claim the following:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;CLAIM: The probability of obtaining different answers on classification tasks done using the ground truth $h$ versus the representations obtained using $q(h_t \mid x_t)$ is less than $\epsilon$ if $KL(q(h_t \mid x_t) \parallel p(h_t \mid x_t)) \leq 2\epsilon^2.$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Here’s a proof sketch.   The natural distance these two distributions $q(h \mid x)$ and $p(h \mid x)$ with respect to accuracy of classification tasks is &lt;em&gt;total variation (TV)&lt;/em&gt; distance. Indeed, if the TV distance between $q(h\mid x)$ and $p(h \mid x)$ is bounded by $\epsilon$, this implies that for any event $\Omega$,&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\left|\Pr_{h_t \sim p(\cdot \mid x_t)}[\Omega] - \Pr_{h_t \sim q(\cdot \mid x_t)}[\Omega]\right| \leq \epsilon .&lt;/script&gt;

&lt;p&gt;The CLAIM now follows by instantiating this with the event $\Omega = $  “Classifier $\mathcal{C}$ outputs a different answer from $y_t$ given representation $h_t$ for input $x_t$”, and relating TV distance to KL divergence using &lt;a href=&quot;https://en.wikipedia.org/wiki/Pinsker%27s_inequality&quot;&gt;Pinsker’s inequality&lt;/a&gt;, which gives&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\mbox{TV}(q(h_t \mid x_t),p(h_t \mid x_t)) \leq  \sqrt{\frac{1}{2} KL(q(h_t \mid x_t) \parallel p(h_t \mid x_t))} \leq \epsilon&lt;/script&gt;

&lt;p&gt;as we needed. This observation explains why solving Task A in practice does not automatically lead to very useful representations for classification tasks (Task C): the posterior distribution has to be learnt extremely accurately, which probably didn’t happen (either due to model mismatch or computational complexity).&lt;/p&gt;

&lt;h2 id=&quot;the--link-between-tasks-a-and-c-variational-methods&quot;&gt;The  link between Tasks A and C: variational methods&lt;/h2&gt;

&lt;p&gt;As noted, distribution learning (Task A) via cross-entropy/maximum-likelihood fitting, and representation learning  (Task C) via sampling the posterior are fairly distinct. Why do students often conflate the two?  Because in practice the most frequent way to solve Task A does  implicitly compute posteriors and thus also solves Task C.&lt;/p&gt;

&lt;p&gt;The generic way to learn latent variable models involves variational methods, which can be viewed as a generalization of the famous EM algorithm  (&lt;a href=&quot;http://web.mit.edu/6.435/www/Dempster77.pdf&quot;&gt;Dempster et al. 1977&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Variational methods maintain at all times a &lt;em&gt;proposed distribution&lt;/em&gt; $q(h | x)$ (called &lt;em&gt;variational distribution&lt;/em&gt;). The methods rely on the observation  that for every such $q(h \mid x)$ the following lower bound holds
\begin{equation} \log p(x) \geq E_{q(h \mid x)} \log p(x,h) + H(q(h\mid x))  \qquad (2). \end{equation}
where $H$ denotes Shannon entropy (or differential entropy, depending on whether $x$ is discrete or continuous). The RHS above is often called the &lt;em&gt;ELBO bound&lt;/em&gt; (ELBO = evidence-based lower bound). This inequality follows from a bit of algebra using non-negativity of KL divergence, applied to distributions $q(h \mid x)$ and $p(h\mid x)$. More concretely, the chain of inequalities is as follows,&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;KL(q(h\mid x) \parallel p(h \mid x)) \geq 0 \Leftrightarrow E_{q(h|x)} \log \frac{q(h|x)}{p(h|x)} \geq 0&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\Leftrightarrow  E_{q(h|x)} \log \frac{q(h|x)}{p(x,h)} + \log p(x) \geq 0&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\Leftrightarrow \log p(x) \geq  E_{q(h|x)} \log p(x,h) + H(q(h\mid x))&lt;/script&gt;

&lt;p&gt;Furthermore, &lt;em&gt;equality&lt;/em&gt; is achieved if $q(h\mid x) = p(h\mid x)$. (This can be viewed as some kind of “duality” theorem for distributions, and dates all the way back to Gibbs. )&lt;/p&gt;

&lt;p&gt;Algorithmically observation (2) is used by foregoing solving the maximum-likelihood optimization (1), and solving instead&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\max_{\theta, q(h_t|x_t)} \sum_{t} E_{q(h_t\mid x_t)} \log p(x_t,h_t) + H(q(h_t\mid x_t))&lt;/script&gt;

&lt;p&gt;Since the variables are naturally divided into two blocks: the model parameters $\theta$, and the variational distributions $q(h_t\mid x_t)$, a natural way to optimize the above is to &lt;em&gt;alternate&lt;/em&gt; optimizing over each group, while keeping the other fixed. (This meta-algorithm is often called variational EM for obvious reasons.)&lt;/p&gt;

&lt;p&gt;Of course, optimizing over all possible distributions $q$ is an ill-defined problem, so $q$ is constrained to lie in some parametric family (e.g., “ standard Gaussian transformed by depth $4$ neural nets of certain size and architecture”) such the above objective can be easily evaluated at least (typically it has a closed-form expression).&lt;/p&gt;

&lt;p&gt;Clearly if the parametric family of distributions  is expressive enough, and the (non-convex) optimization problem doesn’t get stuck in bad local minima, then variational EM algorithm will give us not only values of the parameters $\theta$ which are close to the ground-truth ones, but also variational distributions $q(h\mid x)$ which accurately track $p(h\mid x)$. But as we saw above, this accuracy would need to be very high to get meaningful representations.&lt;/p&gt;

&lt;h2 id=&quot;next-post&quot;&gt;Next Post&lt;/h2&gt;

&lt;p&gt;In the next post, we will describe our recent work further clarifying this issue of representation learning via a Bayesian viewpoint.&lt;/p&gt;
</description>
        <pubDate>Mon, 26 Jun 2017 21:00:00 -0700</pubDate>
        <link>http://offconvex.github.io/2017/06/26/unsupervised1/</link>
        <guid isPermaLink="true">http://offconvex.github.io/2017/06/26/unsupervised1/</guid>
      </item>
     
    
     
      <item>
        <title>Generalization and Equilibrium in Generative Adversarial Networks (GANs)</title>
        <description>&lt;p&gt;The &lt;a href=&quot;http://www.offconvex.org/2017/03/15/GANs/&quot;&gt;previous post&lt;/a&gt; described Generative Adversarial Networks (GANs), a technique for training generative models for image distributions (and other complicated distributions) via a 2-party game between a generator deep net and a discriminator deep net.  This post describes &lt;a href=&quot;https://arxiv.org/abs/1703.00573&quot;&gt;my new paper&lt;/a&gt; with Rong Ge, Yingyu Liang, Tengyu Ma, and Yi Zhang. We address some fundamental issues about generalization in GANs that have been debated since the beginning; e.g., what is the sense in which the learnt distribution close to the target distribution, and also what kind of equilibrium exists between generator and discriminator.&lt;/p&gt;

&lt;p&gt;The usual analysis of GANs,  sketched in the previous post,  assumes “sufficiently large number of samples and sufficiently large discriminator nets” to conclude that at the end of training the learnt distribution should be close to the target distribution. Our new analysis, which accounts for the finite capacity of the discriminator net, calls this into question.&lt;/p&gt;

&lt;p&gt;Readers looking for new implementation ideas can skip ahead to the section below on our  &lt;em&gt;Mix + GAN&lt;/em&gt; protocol. It takes other GANs codes as black box and (by adding extra capacity and corresponding training time) often improves the learnt distribution in qualitative and quantitative measures. Our  testing suggests that it works well out of the box.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Notation&lt;/strong&gt; Assume images are represented as vectors in $\Re^d$. Typically $d$ would be  $1000$ or much higher. The &lt;em&gt;capacity&lt;/em&gt; of the discriminator, namely, the number of trainable parameters, is denoted $n$. The distribution on all real-life images is denoted $P_{real}$. We assume that the number of distinct images in 
$P_{real}$ —regardless of how one defines “distinct”—is enormous compared to all these parameters.&lt;/p&gt;

&lt;p&gt;Recall that the discriminator $D$ is trained to distinguish between samples from $P_{real}$ and samples from the generator’s distribution
$P_{synth}$. This can be formalized using different measures (leading to different GANs objectives) and for simplicity our exposition here uses the &lt;em&gt;distinguishing probability&lt;/em&gt; which is used in &lt;a href=&quot;https://arxiv.org/abs/1701.07875&quot;&gt;Wasserstein GAN&lt;/a&gt; objective:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;|~E_{x \in P_{real}}[D(x)] - E_{x \in P_{synth}}[D(x)]|\qquad (1).&lt;/script&gt;

&lt;p&gt;(Readers with a background in theoretical CS and cryptography will be reminded of similar definitions in theory of pseudorandom generators.)&lt;/p&gt;

&lt;h2 id=&quot;finite-discriminators-have-limited-power&quot;&gt;Finite Discriminators have limited power&lt;/h2&gt;

&lt;p&gt;The following simple fact shows why ignoring the discriminator’s capacity constraint can lead to grossly incorrect intuition. 
(The constant $C$ is fairly small and explained in the paper.)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Theorem 1&lt;/strong&gt;  Suppose the discriminator has capacity  $n$.  Then expression (1) is less than $\epsilon$ when  $P_{synth}$ is the following:  uniform distribution on a random sample of $C n/\epsilon^2 \log n$ images from $P_{real}$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Note that this theorem is not a formalization of the usual failure mode discussed in GANs literature, whereby the generator simply memorizes the training images.  The theorem still applies if we allow the discriminator to use a large set of held out images from $P_{real}$, which are completely different than images in $P_{synth}$. Or, if the training set of images is much larger than  $C n/\epsilon^2 \log n$  images. Furthermore, common measures of diversity/novelty used in research papers (e.g., pick a random image from $P_{synth}$ and check the “distance” to the nearest neighbor among the training set) are not guaranteed to get around the problem raised by Theorem 1.&lt;/p&gt;

&lt;p&gt;Since $Cn/\epsilon^2\log n$ is rather small, this theorem says that a finite-capacity discriminator is unable to even enforce that $P_{synth}$ has  large &lt;em&gt;diversity&lt;/em&gt;, let alone enforce that $P_{synth}\approx P_{real}$.   The theorem does not imply that existing GANs do not &lt;em&gt;in practice&lt;/em&gt; generate diverse distributions; merely that the current analyses gives no reason to believe that they do so.&lt;/p&gt;

&lt;p&gt;The proof of the Theorem is a standard sampling argument from learning theory: take an $\epsilon$-net in the continuum of all deep nets of capacity $n$ and a fixed architecture, and do a union bound. Please see the paper for details. (Aside: the “$\epsilon^2$” term in Theorem 1 arises from this argument, and is ubiquitous in ML theory.)&lt;/p&gt;

&lt;p&gt;Motivated by this theorem, we argue in the paper  that the correct way to think about generalization for GANs is not the usual distance functions between distributions such as Jensen-Shannon or Wasserstein, but a new distance we define called &lt;em&gt;Neural net distance&lt;/em&gt;. The neural net distance measures the ability of finite-capacity deep nets to distinguish the distributions. It can be small even when the other distances are large (as illustrated in the above theorem).&lt;/p&gt;

&lt;h3 id=&quot;corollary-larger-training-sets-have-limited-utility&quot;&gt;Corollary: Larger training sets have limited utility&lt;/h3&gt;

&lt;p&gt;In fact theorem 1 has the following rephrasing. Suppose we have a very large training set of images. If the discriminator has capacity $n$, then it suffices to take a subsample of size $C n/\epsilon^2 \log n$  from this training set, and we are guaranteed that GANs training using this subsample is capable of achieving a training objective that is within $\epsilon$ of the best achieved with the full training set. ( Any more samples can only improve the training objective by at most $\epsilon$. )&lt;/p&gt;

&lt;h2 id=&quot;existence-of-equilibrium&quot;&gt;Existence of Equilibrium&lt;/h2&gt;

&lt;p&gt;Let’s recall the objective used in GAN   (for simplicity, we again stick with the  Wasserstein GAN):&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\min_{G} \max_{D}~~E_{x\sim P_{real}}[D(x)] - E_{h}[D(G(h))] \qquad (1)&lt;/script&gt;
where $G$ is the generator net, and $P_{synth}$ is the distribution of $G(h)$ where $h$ is a random seed. Researchers have noted that this is implicitly a $2$-person game and it may not have an equilibrium; e.g., see the discussion around Figure 22 in &lt;a href=&quot;https://arxiv.org/pdf/1701.00160.pdf&quot;&gt;Goodfellow’s survey&lt;/a&gt;. An &lt;em&gt;equilibrium&lt;/em&gt; corresponds to a $G$ and a $D$ such that the pair are still a solution if we switch the order of min and max in (1). (That is, $G$ doesn’t have incentive to switch in response to $D$, and vice versa.) Lack of equilibrium may be a cause of oscillatory behavior observed in training.&lt;/p&gt;

&lt;p&gt;But ideally we wish to show something stronger than mere &lt;em&gt;existence&lt;/em&gt; of equilibrium: we wish to exhibit an equilibrium where the generator &lt;em&gt;wins&lt;/em&gt;, with the objective above at zero or close to zero (in other words, discriminator is unable to distinguish between the two distributions).&lt;/p&gt;

&lt;p&gt;We will prove existence of an $\epsilon$-&lt;em&gt;approximate equilibrium&lt;/em&gt;, whereby switching the order of $G, D$ affects the expression by at most $\epsilon$. (That is, $G$ has only limited incentive to switch in respnse to $D$ and vice versa.) Naively one would imagine that proving such a result involves some insight into the distribution $P_{real}$ but surprisingly none is needed.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Theorem 2&lt;/strong&gt; If a generator net of capacity $T$ is able to generate a Gaussian distribution in $\Re^d$, then there exists an $\epsilon$-approximate equilibrium in the game where the generator has capacity $O(n T\log n/\epsilon^2 )$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Proof sketch:&lt;/em&gt; A classical result in nonparametric statistics states that $P_{real}$ can be well-approximated by an &lt;em&gt;infinite&lt;/em&gt; mixture of standard Gaussians. Now take a sample of size $O(n\log n/\epsilon^2)$ from this infinite mixture, and let $G$ be a uniform mixture on this finite sample of Gaussians. By an argument similar to Theorem 1, the distribution output by $G$ will be indistinguishable from $P_{real}$ by every deep net of capacity $n$. Finally, fold in this mixture of $O(n\log n/\epsilon^2)$ Gaussians into a single generator by using a small “selector” circuit that selects between these with the correct probability.&lt;/p&gt;

&lt;p&gt;This theorem only shows &lt;em&gt;existence&lt;/em&gt; of a particular  equilibrium. What a GAN may actually find in practice using backpropagation is not addressed.&lt;/p&gt;

&lt;p&gt;Finally, if we are interested in objectives other than Wasserstein GAN, then a similar proof can show the existence of an
$\epsilon$-approximate &lt;em&gt;mixed&lt;/em&gt; equilibrium, namely, where the discriminator and generator are themselves  small mixtures of 
deep nets.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Aside:&lt;/em&gt; The sampling idea in this proof goes back to  &lt;a href=&quot;http://dl.acm.org/citation.cfm?id=195447&quot;&gt;Lipton and Young 1994&lt;/a&gt;.
Similar ideas have also appeared in study of pseudorandomness (see &lt;a href=&quot;http://ieeexplore.ieee.org/document/5231258/citations&quot;&gt;Trevisan et al 2009&lt;/a&gt;) and model criticism (see &lt;a href=&quot;http://www.jmlr.org/papers/volume13/gretton12a/gretton12a.pdf&quot;&gt;Gretton et al 2012&lt;/a&gt;.)&lt;/p&gt;

&lt;h2 id=&quot;mix--gan-protocol&quot;&gt;MIX + GAN protocol&lt;/h2&gt;

&lt;p&gt;Our theory  shows that using a mixture of (not too many) generators and discriminators guarantees existence of approximate equilibrium. This suggests that GANs training may be better and more stable we replace the simple generator and discriminator with mixtures of generators.&lt;/p&gt;

&lt;p&gt;Of course, it is impractical to use very large mixtures, so we propose  &lt;strong&gt;MIX + GAN&lt;/strong&gt;: use a mixture of $k$ components, where $k$ is as large as allowed by size of GPU memory. Namely, train a mixture of $k$ generators ${G_{u_i}, i\in [k]}$ and $k$ discriminators ${D_{v_i}, i\in [k]}$). All components of the mixture share the same network architecture but have their own trainable parameters.  Maintaining a mixture means of course maintaining a  weight $w_{u_i}$ for the generator $G_{u_i}$ which corresponds to the probability of selecting the output of $G_{u_i}$. These weights are also updated via backpropagation.  This heuristic can be combined with existing
methods like DC-GAN, W-GAN etc., giving us new training methods MIX + DC-GAN, MIX + W-GAN etc.&lt;/p&gt;

&lt;p&gt;Some other experimental details: store the mixture probabilities using logarithm and use &lt;a href=&quot;https://users.soe.ucsc.edu/~manfred/pubs/J36.pdf&quot;&gt;exponentiated gradient&lt;/a&gt; to update. Use an entropy regularizer to prevent collapse of the mixture to single component. All of these are theoretically justified if $k$ were very large, and are only heuristic when $k$ is as small as $5$.&lt;/p&gt;

&lt;p&gt;We show that MIX+GAN can improve performance qualitatively (i.e., the images look better) and also quantitatively using popular measures such as Inception score.&lt;/p&gt;

&lt;div style=&quot;text-align:center;&quot;&gt;
&lt;img style=&quot;width:375px;&quot; src=&quot;http://www.cs.princeton.edu/~arora/img/celeA_dcgan.png&quot; /&gt; $\quad$ &lt;img style=&quot;width:375px;&quot; src=&quot;http://www.cs.princeton.edu/~arora/img/celeA_mixgan.png&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;Note that using a mixture increases the capacity of the model by a factor $k$, so it may not be entirely fair to compare the performance of MIX + X with X. On the other hand, in general it is not easy to get substantial performance benefit from increasing deep net capacity (in fact obvious ways of adding capacity that we tried actually reduced performance)   whereas here the benefit happens out of the box.&lt;/p&gt;

&lt;p&gt;Note that a mixture of generators or discriminators has been used in several recent works (cited in our paper), but we are not aware of any attempts to use a trainable mixture as above.&lt;/p&gt;

&lt;h2 id=&quot;take-away-lessons&quot;&gt;Take-Away Lessons&lt;/h2&gt;

&lt;p&gt;Complete understanding of GANs is challenging since we cannot even fully analyse simple backpropagation, let alone backpropagation combined with  game-theoretic complications.&lt;/p&gt;

&lt;p&gt;We therefore set aside issues of algorithmic convergence and focused on generalization and equilibrium, which focus on the maximum value of the objective. Our analysis suggests the following:&lt;/p&gt;

&lt;p&gt;(a) Current GANs training uses a finite capacity deep net to distinguish between synthetic and real distributions. This training criterion by itself seems insufficient to ensure even good &lt;em&gt;diversity&lt;/em&gt; in the synthetic distribution, let alone that it is actually very closes to $P_{real}$. (Theorem 1) A first step to fix this would be to focus on ways to ensure higher diversity, which is a necessary step towards ensuring $P_{synth} \approx P_{real}$.&lt;/p&gt;

&lt;p&gt;(b) Our results seem to pose a conundrum about the GANs idea which I personally have not been able to resolve. Usually, we believe that adding capacity to the generator  allows it gain representation power to model more fine-grained facts about the world and thus produce more realistic and diverse distributions. The downside to adding capacity is &lt;em&gt;overfitting&lt;/em&gt;, which can be mitigated using more training images. Thus one imagines that the ideal configuration is:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Number of training images &amp;gt;  Generator capacity &amp;gt; Discriminator capacity.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Theorem 1 suggests that if discriminator has capacity $n$ then it seems to derive very little benefit (at least in terms of the training objective) from a training set of more than $C (n\log n)/\epsilon^2$ images. Furthermore, there exist equilibria where the generator’s distribution is not too diverse.&lt;/p&gt;

&lt;p&gt;So  how can we change GANs training so that it ensures  $P_{synth}$ having high diversity? Some possibilities are 
(a) cap the generator capacity to be much below discriminator capacity. This might work but I don’t see a mathematical reason why. It certainly flies against the usual intuition that —so long as training dataset is large enough—more capacity allows generators to produce more realistic images. (b) high diversity results from some as-yet unknown property of back propagation algorithm (c) Change GANs setup in some other way.&lt;/p&gt;

&lt;p&gt;At the very least our paper suggests that an explanation for good performance in  GANs must draw upon some delicate interplay of the power of generator vs discriminator and the backpropagation algorithm. This fact was overlooked in previous analyses which assumed discriminators of infinite capacity.&lt;/p&gt;

&lt;p&gt;(&lt;em&gt;I thank Moritz Hardt, Kunal Talwar, and Luca Trevisan for their comments and help with references.&lt;/em&gt;)&lt;/p&gt;
</description>
        <pubDate>Thu, 30 Mar 2017 11:00:00 -0700</pubDate>
        <link>http://offconvex.github.io/2017/03/30/GANs2/</link>
        <guid isPermaLink="true">http://offconvex.github.io/2017/03/30/GANs2/</guid>
      </item>
     
    
     
      <item>
        <title>Generative Adversarial Networks (GANs), Some Open Questions</title>
        <description>&lt;p&gt;Since ability to generate “realistic-looking” data may be a step towards understanding its structure and exploiting it, generative models are an important component of unsupervised learning, which has been a frequent theme on this blog.  Today’s post is about Generative Adversarial Networks (GANs), introduced in 2014 by &lt;a href=&quot;https://arxiv.org/abs/1406.2661&quot;&gt;Goodfellow et al.&lt;/a&gt;, which have quickly become very popular way to train generative models for complicated real-life data. It involves a game-theoretic tussle between a generator player and a discriminator player, which is very attractive and may be useful in other settings.&lt;/p&gt;

&lt;p&gt;This post describes GANs and raises some open questions about them. The next post will describe &lt;a href=&quot;https://arxiv.org/abs/1703.00573&quot;&gt;our recent paper&lt;/a&gt; addressing these questions.&lt;/p&gt;

&lt;p&gt;A generative model $G$ can be seen as taking a random seed $h$ (say, a sample from a multivariate Normal distribution) and converting it into an output string $G(h)$ that “looks” like a real datapoint. Such models are popular in classical statistics but the simpler ones like Gaussian Mixtures or Dirichlet Processes  seem insufficient for modeling complicated distributions on natural images or natural language. Generative models are also popular in statistical physics, e.g., Ising models and their cousins. These physics models migrated into machine learning and neuroscience in the 1980s and 1990s, which led to a new generative  view of neural nets  (e.g., Hinton’s &lt;a href=&quot;https://en.wikipedia.org/wiki/Restricted_Boltzmann_machine&quot;&gt;Restricted Boltzmann Machines&lt;/a&gt;) which in turn led to multilayer generative models such as stacked denoising autoencoders and variational autoencoders. At their heart, these are nothing but multilayer neural nets that transform the random seed into an output that looks like a realistic image. The primary differences in the model concern details of training. Here is the obligatory set of generated images (source:  &lt;a href=&quot;https://openai.com/blog/generative-models/&quot;&gt;OpenAI blog&lt;/a&gt;)&lt;/p&gt;

&lt;div style=&quot;text-align:center;&quot;&gt;
&lt;img style=&quot;height=350px&quot; src=&quot;https://openai.com/assets/research/generative-models/gans-2-6345b04cb02f720a95ea4cb9483e2fd5a5f6e46ec6ea5bbefadf002a010cda82.jpg&quot; /&gt;
&lt;/div&gt;

&lt;h2 id=&quot;gans-the-basic-framework&quot;&gt;GANs: The basic framework&lt;/h2&gt;

&lt;p&gt;GANs also train a deep net $G$  to produce realistic images, but the new and beautiful twist  lies in a novel training procedure.&lt;/p&gt;

&lt;p&gt;To understand the new twist let’s first discuss what it could mean for the output to “look” realistic. A classic evaluation for generative models is &lt;a href=&quot;https://en.wikipedia.org/wiki/Perplexity&quot;&gt;&lt;em&gt;perplexity&lt;/em&gt;&lt;/a&gt;: a measure of the amount of probability it gives to actual images. This requires that the generative model must be accompanied by an algorithm that computes the probability density function for the generated distribution (i.e., given any image, it must output an estimate of the probability that the model outputs this image.) I might do a future blog post discussing pros and cons of the perplexity measure, but today let’s instead dive straight to GANs, which sidestep the need for perplexity computations.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Idea 1:&lt;/strong&gt; Since deep nets are good at recognizing images —e.g., distinguishing pictures of people from pictures of cats—why not let a deep net be the judge of  the outputs of a generative model?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;More concretely, let $P_{real}$ be the distribution over real images, and $P_{synth}$ the one output by the model (i.e., the distribution of $G(h)$ when $h$ is a random seed). We could try to train a discriminator deep net $D$ that maps images to numbers in $[0,1]$ and tries to discriminate between these distributions in the following sense. Its
expected output $E_{x}[D(x)]$ as high as possible when $x$ is drawn from $P_{real}$ and 
 as low as possible when $x$ is drawn from $P_{synth}$.  This training can be done with the &lt;a href=&quot;http://www.offconvex.org/2016/12/20/backprop/&quot;&gt;usual backpropagation&lt;/a&gt;.  If the two distributions are identical then of course no such deep net can exist, and so the training will end in failure. If on the other hand we are able to train a good discriminator deep net —one whose average output is noticeably different between real and synthetic samples— then this is proof positive that the two distributions are different. (There is an in-between case, whereby the distributions are different but the discriminator net doesn’t detect a difference. This is going to be important in the story in the next post.) A natural next question is whether the ability to train such a discriminator deep net can help us improve the generative model.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Idea 2:&lt;/strong&gt; If a good discriminator net has been trained, use it to provide “gradient feedback” that improves the generative model.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Let $G$ denote the Generator net, which means that samples in $P_{synth}$ are obtained by sampling a uniform gaussian seed $h$ and computing $G(h)$. The natural goal for the generator is to make $E_{h}[D(G(h))]$ as high as possible, because that means it is doing better at fooling the discriminator $D$. So if we fix $D$ the natural way to improve $G$ is to pick a few random seeds $h$, and slightly adjust the trainable parameters of $G$ to increase this objective. Note that this gradient computation involves backpropagation through  the composed net $D(G(\cdot))$).&lt;/p&gt;

&lt;p&gt;Of course, if we let the generator improve itself, it also makes sense to then let the discriminator improve itself too, Which leads to:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Idea 3:&lt;/strong&gt;  Turn the training of the generative model into a game of many moves or alternations.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Each move for the discriminator consists of taking a few samples from $P_{real}$  and $P_{synth}$  and improving its ability to discriminate between them. Each move for the generator consists of producing a few samples from $P_{synth}$ and updating its parameters so that $E_{u}[D(G(h))]$ goes up a bit.&lt;/p&gt;

&lt;p&gt;Notice, the discriminator always uses the generator as a black box —i.e., never examines its internal parameters —whereas the generator needs the discriminator’s parameters to compute its gradient direction. Also, the generator does not ever use real images from $P_{real}$   for its computation. (Though of course it does rely on the real images indirectly since the discriminator is trained using them.)&lt;/p&gt;

&lt;h2 id=&quot;gans-more-details&quot;&gt;GANS: More details&lt;/h2&gt;

&lt;p&gt;One can fill in the above framework in multiple ways. The most obvious is that the generator could try to maximize $E_{u}[f(D(G(h)))]$ where $f$ is some increasing function. (We call this the &lt;em&gt;measuring function.&lt;/em&gt;) This has the effect of giving different importance to different samples.   Goodfellow et al. originally   used $f(x)=\log (x)$, which, since the derivative of $\log x$ is $1/x$,  implicitly gives much more importance to synthetic data $G(u)$ where the discriminator outputs very low values $D(G(h))$. In other words, using $f(x) =\log x$ makes the training more sensitive to instances which the discriminator finds terrible than to instances which the discriminator finds so-so. By contrast, the above sketch implicitly used $f(x) =x$, which gives the same importance to all samples and appears in the recent  &lt;a href=&quot;https://arxiv.org/abs/1701.07875&quot;&gt;Wasserstein GAN&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The discussion thus leads to the following mathematical formulation, where $D, G$ are deep nets with specified architecture and whose number of parameters is fixed in advance by the algorithm designer.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\min_{G} \max_{D}~~E_{x\sim P_{real}}[f(D(x))] + E_{h}[f(1-D(G(h)))]. \qquad (1)&lt;/script&gt;

&lt;p&gt;There is now a big industry of improving this basic framework using various architectures and training variations, e.g. (a random sample; possibly missing some important ones): &lt;a href=&quot;https://arxiv.org/abs/1511.06434v2&quot;&gt;DC-GAN&lt;/a&gt;, &lt;a href=&quot;https://arxiv.org/abs/1612.04357&quot;&gt;S-GAN&lt;/a&gt;, &lt;a href=&quot;https://arxiv.org/abs/1609.04802&quot;&gt;SR-GAN&lt;/a&gt;, &lt;a href=&quot;https://arxiv.org/abs/1606.03657&quot;&gt;INFO-GAN&lt;/a&gt;, etc.&lt;/p&gt;

&lt;p&gt;Usually, the  training is continued until the generator wins, meaning the discriminator’s expected output on samples from $P_{real}$  and $P_{synth}$ becomes the same. But a serious  practical difficulty is that training in practice is oscillatory, and the above objective  is observed to go up and down. This is unlike usual deep net training, where training (at least in cases where it works) steadily improves the objective.&lt;/p&gt;

&lt;h2 id=&quot;gans-some-open-questions&quot;&gt;GANS: Some open questions&lt;/h2&gt;

&lt;p&gt;(a)	&lt;em&gt;Does an equilibrium exist?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Since GAN is a 2-person game, the oscillatory behavior mentioned above is not unexpected. Just as a necessary condition for gradient descent to come to a stop is that the current point is a stationary point (ie gradient is zero), the corresponding situation in  a 2-person game is an &lt;em&gt;equilibrium&lt;/em&gt;: each player’s move happens to be its optimal response to the other’s move. In other words, switching the order of $\min$ and $\max$ in expression (1) doesn’t change the objective. The GAN formulation above needs a so-called pure equilibrium, which may not exist in general. A simple example is the classic rock/paper/scissors game. Regardless of whether one player plays rock, paper or scissor as a move, the other can counter with a move that beats it. Thus no pure equilibrium exists.&lt;/p&gt;

&lt;p&gt;(b) &lt;em&gt;Does an equilibrium exist where the generator wins, i.e. discriminator ends up unable to distinguish the two distributions on finite samples?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;(c) &lt;em&gt;Suppose the generator wins. What does this say about whether or not&lt;/em&gt; $P_{real}$  &lt;em&gt;is close to&lt;/em&gt; $P_{synth}$ ?&lt;/p&gt;

&lt;p&gt;Question (c) has dogged GANs research from the start. Has the generative model actually learned something meaningful about real life images, or is it somehow memorizing existing images and presenting trivial modifications?  (Recall that $G$ is never exposed directly to real images, so any “memorizing” has to be happen via the gradient propagated through the discriminator.)&lt;/p&gt;

&lt;p&gt;If generator’s win does indeed say that $P_{real}$  and $P_{synth}$  are close then we think of the GANs training as &lt;em&gt;generalizing.&lt;/em&gt; (This by analogy to the usual notion of generalization for supervised learning.)&lt;/p&gt;

&lt;p&gt;In fact,  the next post will show that this issue is indeed more subtle than hitherto recognized. But to complete the backstory I will summarize how this issue has been studied so far.&lt;/p&gt;

&lt;h2 id=&quot;past-efforts-at-understanding-generalization&quot;&gt;Past efforts at understanding generalization&lt;/h2&gt;

&lt;p&gt;The original paper of Goodfellow et al. introduced an analysis of generalization —adopted since by other researchers— that works  when deep nets are trained “sufficiently high capacity, samples and training time” (to use their phrasing).&lt;/p&gt;

&lt;p&gt;For the original objective function with $f(x) =\log x$ if the optimal discriminator is allowed  to be any function all (i.e., not just one computable by a finite capacity neural net) it can be checked that the optimal choice is $D(x) = P_{real}(x)/(P_{real}(x)+P_{synth}(x))$.
Substituting this in the GANs objective, up to linear transformation the maximum value achieved by discriminator turns out to be
equivalent to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Jensen%E2%80%93Shannon_divergence&quot;&gt;Jensen-Shannon (JS) divergence&lt;/a&gt; between $P_{real}$ and $P_{synth}$. 
Hence if a generator wins the game against this &lt;em&gt;ideal&lt;/em&gt; discriminator on a &lt;em&gt;very large&lt;/em&gt; number of samples, then $P_{real}$ and $P_{synth}$ are close in JS divergence, and thus the model has learnt the true distribution.&lt;/p&gt;

&lt;p&gt;A similar analysis for &lt;a href=&quot;https://arxiv.org/abs/1701.07875&quot;&gt;Wasserstein GANs&lt;/a&gt; shows that if the generator  wins using the Wasserstein objective (i.e., $f(x) =x$) then the two distributions are close in &lt;a href=&quot;https://en.wikipedia.org/wiki/Wasserstein_metric&quot;&gt;Wasserstein or earth-mover distance&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;But we will see in the next post that these analyses can be misleading because in practice, deep nets have (very) finite capacity and 
sample size. Thus even if training produces the optimal discriminator, the above analyses can be very off.&lt;/p&gt;

&lt;h2 id=&quot;further-resources&quot;&gt;Further resources&lt;/h2&gt;

&lt;p&gt;OpenAI has a &lt;a href=&quot;https://openai.com/blog/generative-models/&quot;&gt;brief survey of recent approaches&lt;/a&gt; to generative models. The &lt;a href=&quot;http://www.inference.vc/&quot;&gt;inFERENCe blog&lt;/a&gt; has many articles on GANs.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://arxiv.org/pdf/1701.00160.pdf&quot;&gt;Goodfellow’s survey&lt;/a&gt; is the most authoritative account of this burgeoning field, and gives tons of  insight. The text around Figure 22 discusses oscillation and lack of equilibria.
He also discusses how GANs trained on a broad spectrum of images seem to get confused and output  images that are realistic at the micro level but  nonsensical overall; e.g., an animal with a leg coming out of its head. Clearly this field, despite its promise,  has many open questions!&lt;/p&gt;

</description>
        <pubDate>Wed, 15 Mar 2017 06:00:00 -0700</pubDate>
        <link>http://offconvex.github.io/2017/03/15/GANs/</link>
        <guid isPermaLink="true">http://offconvex.github.io/2017/03/15/GANs/</guid>
      </item>
     
    
     
      <item>
        <title>Back-propagation, an introduction</title>
        <description>&lt;p&gt;Given the sheer number of backpropagation tutorials on the internet, is there really need for another? One of us (Sanjeev) recently taught backpropagation in &lt;a href=&quot;https://www.cs.princeton.edu/courses/archive/fall16/cos402/&quot;&gt;undergrad AI&lt;/a&gt; and couldn’t find any account he was happy with. So here’s our exposition, together with some history and context, as well as a few advanced notions at the end. This article assumes the reader knows the definitions of gradients and neural networks.&lt;/p&gt;

&lt;h2 id=&quot;what-is-backpropagation&quot;&gt;What is backpropagation?&lt;/h2&gt;

&lt;p&gt;It is the basic algorithm in training neural nets, apparently independently rediscovered several times in the 1970-80’s (e.g., see Werbos’ &lt;a href=&quot;https://www.researchgate.net/publication/35657389_Beyond_regression_new_tools_for_prediction_and_analysis_in_the_behavioral_sciences&quot;&gt;Ph.D. thesis&lt;/a&gt; and &lt;a href=&quot;http://www.wiley.com/WileyCDA/WileyTitle/productCd-0471598976.html&quot;&gt;book&lt;/a&gt;, and &lt;a href=&quot;http://www.nature.com/nature/journal/v323/n6088/abs/323533a0.html&quot;&gt;Rumelhart et al.&lt;/a&gt;). Some related ideas existed in control theory in the 1960s. (One reader points out another independent rediscovery, the Baur-Strassen lemma from 1983.)&lt;/p&gt;

&lt;p&gt;Backpropagation gives a fast way to compute the sensitivity of the output of a neural network to all of its parameters while keeping the inputs of the network fixed: specifically it computes all partial derivatives ${\partial f}/{\partial w_i}$ where $f$ is the output and $w_i$ is the $i$th parameter. (Here &lt;em&gt;parameters&lt;/em&gt; can be edge weights or biases associated with nodes or edges of the network, and the precise details of the node computations —e.g., the precise form of nonlinearity like Sigmoid or RELU— are unimportant.)  Doing so gives the &lt;em&gt;gradient&lt;/em&gt; $\nabla f$ of $f$ with respect to its  network parameters, which allows a &lt;em&gt;gradient descent&lt;/em&gt; step in the training: change all parameters simultaneously to move the vector of parameters  a small amount in the direction $-\nabla f$.&lt;/p&gt;

&lt;p&gt;Note that backpropagation computes the gradient exactly, but properly training neural nets needs many more tricks than just backpropagation. Understanding backpropagation is useful for appreciating some advanced tricks.&lt;/p&gt;

&lt;p&gt;The importance of backpropagation derives from its efficiency. Assuming node operations take unit time, the running time is &lt;em&gt;linear&lt;/em&gt;, specifically, $O(\text{Network Size}) = O(V + E)$, where $V$ is the number of nodes in the network and $E$ is the number of edges.  The only technical ingredient  is chain rule from calculus, but applying it naively would have resulted in quadratic running time—which would be hugely inefficient  for networks with millions or even thousands of parameters.&lt;/p&gt;

&lt;p&gt;Backpropagation can be efficiently implemented using highly parallel vector operations available  in today’s &lt;a href=&quot;https://en.wikipedia.org/wiki/General-purpose_computing_on_graphics_processing_units&quot;&gt;GPUs (Graphical Processing Units)&lt;/a&gt;, which play an important role in the the recent neural nets revolution.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Side Note:&lt;/strong&gt; Expert readers will recognize that in the standard accounts of neural net training,
the actual quantity of interest is the gradient of the &lt;em&gt;training loss&lt;/em&gt;, which happens to be a  simple function of the network output. But the above phrasing is fully general since  one can simply add a new output node to the network that computes the training loss from the old output. Then the quantity of interest is indeed the gradient of this new output with respect to network parameters.&lt;/p&gt;

&lt;h2 id=&quot;problem-setup&quot;&gt;Problem Setup&lt;/h2&gt;

&lt;p&gt;Backpropagation applies only to acyclic networks with directed edges. (Later we briefly sketch its use on networks with cycles.)&lt;/p&gt;

&lt;p&gt;Without loss of generality, acyclic networks can be visualized as being structured in numbered layers,  with nodes in the $t+1$th layer getting all their inputs from the outputs of nodes in layers $t$ and earlier. We use $f \in \mathbb{R}$ to denote the output of the network. In all our figures, the input of the network is at the bottom and the output on the top.&lt;/p&gt;

&lt;p&gt;We start with a simple claim that reduces the problem of computing the gradient to the problem of computing partial derivatives with respect to the nodes:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Claim 1:&lt;/strong&gt; To compute the desired gradient with respect to the parameters, it suffices to compute $\partial f/\partial u$ for every node $u$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Let’s be clear what $\partial f/\partial u$ means. Suppose we cut off all the incoming edges of the node $u$, and fix/clamp the current values of all network parameters. Now imagine changing $u$ from its current value. This change may affect values of nodes at higher levels that are connected to $u$,  and the final output $f$ is one such node.  Then $\partial f/\partial u$ denotes the rate at which $f$ will change as we vary $u$. (Aside: Readers familiar with the usual exposition of back-propagation should note that there $f$ is the training error and this $\partial f/\partial u$ turns out to be exactly the “error” propagated back  to on the node $u$.)&lt;/p&gt;

&lt;p&gt;Claim 1 is a direct application of chain rule, and let’s illustrate it for a simple neural nets (we address more general networks later). Suppose node $u$ is a weighted sum of the nodes $z_1,\dots, z_m$ (which will be passed through a non-linear activation $\sigma$ afterwards). That is, we have $u = w_1z_1+\dots+w_nz_n$. By Chain rule, we have&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{\partial f}{\partial w_1} = \frac{\partial f}{\partial u}\cdot \frac{\partial{u}}{\partial w_1} = \frac{\partial f}{\partial u}\cdot z_1.&lt;/script&gt;

&lt;p&gt;Hence, we see that having computed $\partial f/\partial u$ we can compute $\partial f/\partial w_1$, and moreover this can be done locally by the endpoints of the edge where $w_1$ resides.&lt;/p&gt;

&lt;div style=&quot;text-align:center;&quot;&gt;
&lt;img style=&quot;width:500px;&quot; src=&quot;http://www.cs.princeton.edu/~tengyu/forblog/weight5.jpg&quot; /&gt;
&lt;/div&gt;

&lt;h3 id=&quot;multivariate-chain-rule&quot;&gt;Multivariate Chain Rule&lt;/h3&gt;

&lt;p&gt;Towards computing the derivatives with respect to the nodes, we first recall the multivariate Chain rule, which handily describes the relationships between these partial derivatives (depending on the graph structure).&lt;/p&gt;

&lt;p&gt;Suppose a variable $f$ is a function of variables $u_1,\dots, u_n$, which in turn depend on the variable $z$. Then, multivariate Chain rule says that&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{\partial f}{\partial z} = \sum_{j=1}^n \frac{\partial f}{\partial u_j}\cdot \frac{\partial u_j}{\partial z}~.&lt;/script&gt;

&lt;p&gt;This is a direct generalization of eqn. (2) and a sub-case of eqn. (11) in this &lt;a href=&quot;http://mathworld.wolfram.com/ChainRule.html&quot;&gt;description of chain rule&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This formula is perfectly suitable for our cases. Below is the same example as we used before but with a different focus and numbering of the nodes.&lt;/p&gt;

&lt;div style=&quot;text-align:center;&quot;&gt;
&lt;img style=&quot;width:500px;&quot; src=&quot;http://www.cs.princeton.edu/~tengyu/forblog/chain_rule_5.jpg&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;We see that given we’ve computed the derivatives with respect to all the nodes that is above the node $z$, we can compute the derivative with respect to the node $z$ via a weighted sum, where the weights involve the local derivative ${\partial u_j}/{\partial z}$ that is often easy to compute. This brings us to the question of how we measure running time. For book-keeping, we assume that&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Basic assumption:&lt;/strong&gt;  If $u$ is a node at level $t+1$ and $z$ is any node at level $\leq t$ whose output is an input to $u$, then computing $\frac{\partial u}{\partial z}$ takes unit time on our computer.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;naive-feedforward-algorithm-not-efficient&quot;&gt;Naive feedforward algorithm (not efficient!)&lt;/h3&gt;
&lt;p&gt;It is useful to first point out the naive quadratic time algorithm implied by the chain rule.   Most authors skip this trivial version, which we think is analogous to teaching sorting using only quicksort, and skipping over the less efficient bubblesort.&lt;/p&gt;

&lt;p&gt;The naive algorithm is to compute $\partial u_i/\partial u_j$ for every pair of nodes where $u_i$ is at a higher level than $u_j$. Of course, among these $V^2$ values (where $V$ is the number of nodes) are also  the desired  ${\partial f}/{\partial u_i}$ for all $i$  since $f$ is itself the value of the output node.&lt;/p&gt;

&lt;p&gt;This computation  can be done in feedforward fashion. If such value has been obtained for every $u_j$ on the level up to and including level $t$, then one can express (by inspecting the multivariate chain rule) the value $\partial u_{\ell}/\partial u_j$ for some $u_{\ell}$ at level $t+1$ as a weighted combination of values $\partial u_{i}/\partial u_j$ for each $u_i$ that is a direct input to $u_{\ell}$. This description shows that the amount of computation for a fixed $j$ is proportional to the number of edges $E$. This amount of work happens for all $V$ values of $j$, letting us conclude that the total work in the algorithm is $O(VE)$.&lt;/p&gt;

&lt;h2 id=&quot;backpropagation-linear-time&quot;&gt;Backpropagation (Linear Time)&lt;/h2&gt;

&lt;p&gt;The more efficient backpropagation, as the name suggests,  computes the partial derivatives in the reverse direction. Messages are passed in one wave backwards from higher number layers to lower number layers. (Some presentations of the algorithm describe it as dynamic programming.)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Messaging protocol:&lt;/strong&gt;
The node $u$ receives a message along each outgoing edge from the node at the other end of that edge. It sums these messages to get a number $S$ (if $u$ is the output of the entire net, then define $S=1$) and then it sends the following message to any node $z$ adjacent to it at a lower level:
&lt;script type=&quot;math/tex&quot;&gt;S \cdot \frac{\partial u}{\partial z}&lt;/script&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Clearly, the amount of work done by each node is proportional to its degree, and thus overall work is the sum of the node degrees. Summing all node degrees counts each edge twice, and thus the overall work is 
$O(\text{Network Size})$.&lt;/p&gt;

&lt;p&gt;To prove correctness, we prove the following:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Main Claim&lt;/strong&gt;: At each node $z$, the value $S$ is exactly ${\partial f}/{\partial z}$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Base Case&lt;/em&gt;: At the output layer this is true, since ${\partial f}/{\partial f} =1$.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Inductive case&lt;/em&gt;: Suppose the claim was true for layers $t+1$ and higher and $u$ is at layer $t$, with outgoing edges go to some nodes $u_1, u_2, \ldots, u_m$ at levels $t+1$ or higher. By inductive hypothesis, node $z$ indeed receives $ \frac{\partial f}{\partial u_j}\times \frac{\partial u_j}{\partial z}$ from each of $u_j$. Thus by Chain rule, 
&lt;script type=&quot;math/tex&quot;&gt;S= \sum_{i =1}^m \frac{\partial f}{\partial u_i}\frac{\partial u_i}{\partial z}=\frac{\partial f}{\partial z}.&lt;/script&gt;
This completes the induction and proves the Main Claim.&lt;/p&gt;

&lt;h2 id=&quot;auto-differentiation&quot;&gt;Auto-differentiation&lt;/h2&gt;
&lt;p&gt;Since the exposition above used almost no details about the network and the operations that the node perform, it extends to every computation that can be organized as an acyclic graph whose each node computes a differentiable function of its incoming neighbors. This observation underlies many auto-differentiation packages such as &lt;a href=&quot;https://github.com/HIPS/autograd&quot;&gt;autograd&lt;/a&gt; or &lt;a href=&quot;https://www.tensorflow.org/&quot;&gt;tensorflow&lt;/a&gt;: they allow computing the gradient of the output of such a computation with respect to the network parameters.&lt;/p&gt;

&lt;p&gt;We first observe that Claim 1 continues to hold in this very general setting. This is without loss of generality because we can view the parameters associated to the edges as also sitting on the nodes (actually, leaf nodes). This can be done via a simple transformation to the network;  for a single node it is shown in the picture below; and one would need to continue to do this transformation in the rest of the networks feeding into $u_1, u_2,..$ etc from below.&lt;/p&gt;

&lt;div style=&quot;text-align:center;&quot;&gt;
&lt;img style=&quot;width:800px;&quot; src=&quot;http://www.cs.princeton.edu/~tengyu/forblog/change_view&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;Then, we can use the messaging protocol to compute the derivatives with respect to the nodes, as long as the local partial derivative can be computed efficiently. We note that the algorithm can be implemented in a fairly modular manner: For every node $u$, it suffices to specify (a) how it depends on the incoming nodes, say, $z_1,\dots, z_n$  and (b) how to compute the partial derivative times $S$, that is, $S \cdot \frac{\partial u}{\partial z_j}$.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Extension to vector messages&lt;/em&gt;: In fact (b) can be done efficiently in more general settings where we allow the output of each node in the network to be a vector (or even matrix/tensor) instead of only a real number. Here we need to replace $\frac{\partial u}{\partial z_j}\cdot S$ by $\frac{\partial u}{\partial z_j}[S]$, which denotes the result of applying the operator $\frac{\partial u}{\partial z_j}$ on $S$. We note that to be consistent with the convention in the usual exposition of backpropagation, when $y\in \mathbb{R}^{p}$ is a funciton of $x\in \mathbb{R}^q$, we use $\frac{\partial y}{\partial x}$ to denote $q\times p$ dimensional matrix with $\partial y_j/\partial x_i$ as the $(i,j)$-th entry. Readers might notice that this is the transpose of the usual Jacobian matrix defined in mathematics. Thus $\frac{\partial y}{\partial x}$ is an operator that maps $\mathbb{R}^p$ to $\mathbb{R}^q$ and we can verify $S$ has the same dimension as $u$ and $\frac{\partial u}{\partial z_j}[S]$ has the same dimension as $z_j$.&lt;/p&gt;

&lt;p&gt;For example, as illustrated below, suppose the node $U\in \mathbb{R}^{d_1\times d_3} $ is a product of two matrices $W\in \mathbb{R}^{d_2\times d_3}$ and $Z\in \mathbb{R}^{d_1\times d_2}$. Then we have that $\partial U/\partial Z$ is a linear operator that maps $\mathbb{R}^{d_2\times d_3}$ to $\mathbb{R}^{d_1\times d_3}$, which naively requires a matrix representation of dimension $d_2d_3\times d_1d_3$. However, the computation (b) can be done efficiently because 
&lt;script type=&quot;math/tex&quot;&gt;\frac{\partial U}{\partial Z}[S]= W^{\top}S.&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Such vector operations can also be implemented efficiently using today’s GPUs.&lt;/p&gt;

&lt;div style=&quot;text-align:center;&quot;&gt;
&lt;img style=&quot;width:200px;&quot; src=&quot;http://www.cs.princeton.edu/~tengyu/forblog/mult.jpg&quot; /&gt;
&lt;/div&gt;

&lt;h2 id=&quot;notable-extensions&quot;&gt;Notable Extensions&lt;/h2&gt;

&lt;p&gt;1) &lt;em&gt;Allowing weight tying.&lt;/em&gt; In many neural architectures, the designer wants to force many network units such as edges or nodes to share the same parameter. For example, in &lt;a href=&quot;https://en.wikipedia.org/wiki/Convolutional_neural_network&quot;&gt;&lt;em&gt;convolutional neural nets&lt;/em&gt;&lt;/a&gt;, the same filter has to be applied all over the image, which implies reusing the same parameter for a large set of edges between the two layers.&lt;/p&gt;

&lt;p&gt;For simplicity, suppose two parameters $a$ and $b$ are supposed to share the same value. This is equivalent to adding a new node $u$ and connecting $u$ to both $a$ and $b$ with the operation $a = u$ and $b=u$. Thus, by chain rule, &lt;script type=&quot;math/tex&quot;&gt;\frac{\partial f}{\partial u} = \frac{\partial f}{\partial a}\cdot \frac{\partial a}{\partial u}+\frac{\partial f}{\partial b}\cdot \frac{\partial b}{\partial u} =  \frac{\partial f}{\partial a}+ \frac{\partial f}{\partial b}.&lt;/script&gt; Hence, equivalently, the gradient with respect to a shared parameter is the sum of the gradients with respect to individual occurrences.&lt;/p&gt;

&lt;p&gt;2) &lt;em&gt;Backpropagation on networks with loops.&lt;/em&gt; The above exposition assumed the network is acyclic.   Many cutting-edge applications such as machine translation and language understanding use networks with directed loops (e.g., recurrent neural networks). These architectures —all examples of the “differentiable computing” paradigm below—can get complicated and may involve operations on a separate memory as well as mechanisms to shift attention to different parts of data and memory.&lt;/p&gt;

&lt;p&gt;Networks with loops are trained using gradient descent as well, using  &lt;a href=&quot;https://en.wikipedia.org/wiki/Backpropagation_through_time&quot;&gt;back-propagation through time&lt;/a&gt;, which consists of expanding the network through a finite number of time steps into an acyclic graph, with replicated copies of the same
network. These replicas share the weights  (weight tying!) so the gradient can be computed. In practice an issue may arise  with &lt;a href=&quot;https://en.wikipedia.org/wiki/Vanishing_gradient_problem&quot;&gt;exploding or vanishing gradients&lt;/a&gt; which impact convergence. Such issues can be carefully addressed in practice by clipping the gradient or re-parameterization techniques such as  &lt;a href=&quot;https://en.wikipedia.org/wiki/Long_short-term_memory&quot;&gt;long short-term memory&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The fact that the gradient can be computed efficiently for such general networks with loops has motivated neural net models  with memory or even data structures (see for example &lt;a href=&quot;https://en.wikipedia.org/wiki/Neural_Turing_machine&quot;&gt;neural Turing machines&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Differentiable_neural_computer&quot;&gt;differentiable neural computer&lt;/a&gt;). Using gradient descent, one can optimize over a family of parameterized networks with loops to find the best one that solves a certain computational task (on the training examples).  The limits of these ideas are still being explored.&lt;/p&gt;

&lt;p&gt;3) &lt;em&gt;Hessian-vector product in linear time.&lt;/em&gt; It is possible to generalize backprop to enable 2nd order optimization in “near-linear” time, not just gradient descent,
as shown in recent independent manuscripts of &lt;a href=&quot;https://arxiv.org/pdf/1611.00756.pdf&quot;&gt;Carmon et al.&lt;/a&gt; and &lt;a href=&quot;https://arxiv.org/pdf/1611.01146.pdf&quot;&gt;Agarwal et al.&lt;/a&gt; (NB: Tengyu is a coauthor on this one.).  One essential step is to
compute the product of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Hessian_matrix&quot;&gt;Hessian matrix&lt;/a&gt; and a  vector, for which &lt;a href=&quot;http://www.bcl.hamilton.ie/~barak/papers/nc-hessian.pdf&quot;&gt;Pearlmutter’93&lt;/a&gt; gave an efficient algorithm.  Here we show how to do this in $O(\mbox{Network size})$ using the ideas above. We need a slightly stronger version of the back-propagation result than the one in the previous subsection:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Claim (informal):&lt;/strong&gt; Suppose an acyclic network with $V$ nodes and $E$ edges has output $f$ and leaves $z_1,\dots, z_m$. Then there exists a network of size $O(V+E)$ that has $z_1,\dots, z_m$ as input nodes and $\frac{\partial f}{\partial z_1},\dots, \frac{\partial f}{\partial z_m}$ as output nodes.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The proof of the Claim follows in straightforward fashion from implementing the message passing protocol as an acyclic circuit.&lt;/p&gt;

&lt;p&gt;Next we show how to compute $\nabla^2 f(z)\cdot v$ where $v$ is a given fixed vector. Let $g(z)= \langle \nabla f(z),v\rangle$ be a function from $\mathbb{R}^d\rightarrow \mathbb{R}$. Then by the Claim above, $g(z)$ can be computed by a network of size $O(V+E)$. Now apply the Claim again on $g(z)$, we obtain that $\nabla g(z)$ can also be computed by a network of size $O(V+E)$.&lt;/p&gt;

&lt;p&gt;Note that by construction, 
&lt;script type=&quot;math/tex&quot;&gt;\nabla g(z) =  \nabla^2 f(z)\cdot v.&lt;/script&gt;
Hence we have computed the Hessian vector product in network size time.&lt;/p&gt;

&lt;p&gt;##That’s all!&lt;/p&gt;

&lt;p&gt;Please write your comments on  this exposition and whether it can be improved.&lt;/p&gt;

</description>
        <pubDate>Tue, 20 Dec 2016 09:00:00 -0800</pubDate>
        <link>http://offconvex.github.io/2016/12/20/backprop/</link>
        <guid isPermaLink="true">http://offconvex.github.io/2016/12/20/backprop/</guid>
      </item>
     
    
     
      <item>
        <title>The search for biologically plausible neural computation&amp;#58; The conventional approach</title>
        <description>&lt;p&gt;Inventors of the original artificial neural networks (NNs) derived their inspiration from biology. 
However, as artificial NNs progressed, their design was less guided by neuroscience facts. 
Meanwhile, progress in neuroscience has altered our conceptual understanding of neurons. 
Consequently, we believe that many successful artificial NNs resemble natural NNs only
superficially violating fundamental constraints imposed by biological hardware.&lt;/p&gt;

&lt;p&gt;The wide gap between the artificial and natural NN designs raises intriguing questions: What 
algorithms underlie natural NNs? Can insights from biology help build better artificial 
NNs?&lt;/p&gt;

&lt;p&gt;This is the first of a series of posts aimed at explaining recent progress made
by my collaborators and myself towards biologically plausible NNs. Such networks can 
serve both as models of natural NNs and as general 
purpose artificial NNs. We have found that respecting biological constraints 
actually helps development of artificial NNs by guiding design decisions.&lt;/p&gt;

&lt;p&gt;In this post, I cover the background material, going back several decades. 
I sketch a biological neuron, introduce primary biological constraints, and discuss 
the conventional approach to deriving artificial NNs. I will show that while 
the conventional approach generates a reasonable algorithmic model of a &lt;em&gt;single&lt;/em&gt; 
biological neuron, multi-neuron networks violate biological constraints. In future 
posts we will see how to fix that.&lt;/p&gt;

&lt;h2 id=&quot;a-sketch-of-a-biological-neuron&quot;&gt;A Sketch of a Biological Neuron&lt;/h2&gt;

&lt;p&gt;Here is the minimum biological background needed to understand the rest of the post.&lt;/p&gt;

&lt;p&gt;A biological neuron receives signals from multiple neurons, computes their weighted sum and 
generates a signal transmitted to multiple neurons, Figure 1. Each neuron’s signaling activity is 
quantified by the &lt;em&gt;firing rate&lt;/em&gt;, which is a nonnegative real number that varies over time. Each synapse 
scales the input from the corresponding upstream neuron onto the receiving neuron by its 
weight. The receiving neuron sums scaled inputs, i.e. computes the inner product of the 
upstream activity vector and the synaptic weight vector. The inner product passes 
through a nonlinearity called the activation function and the output is transmitted 
to downstream neurons.&lt;/p&gt;

&lt;p&gt;Synaptic weight changes over time, typically, on a slower time scale than neuronal signals. The 
weight depends on neuronal signals per so-called learning rules. For example, in commonly 
used &lt;a href=&quot;https://en.wikipedia.org/wiki/Hebbian_theory&quot;&gt;Hebbian learning rules&lt;/a&gt;, synaptic weight is 
proportional to the correlation between the activities of the two neurons a synapse connects, 
i.e. pre- and postsynaptic.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://docs.google.com/uc?export=download&amp;amp;id=0B5Pfjcu55RQQb0F1MllnRTdweDQ&quot; alt=&quot;&quot; title=&quot;Title&quot; /&gt;
Figure 1: A biological neuron modelled by an online algorithm. Left: A biological neuron receives 
inputs from the upstream neurons (green) which are scaled by the weights of corresponding 
synapses (blue). The neuron (black) computes output, $y$, as a function of the weighted input sum. Right: Online algorithm outputs an activation function of the inner product of the 
synaptic weight vector and an upstream activity vector. Synaptic weights are modified by 
neuronal activities (dashed line) per learning rules.&lt;/p&gt;

&lt;h2 id=&quot;primary-biological-constraints&quot;&gt;Primary Biological Constraints&lt;/h2&gt;

&lt;p&gt;To determine which algorithmic models in this post are biologically plausible, 
we can focus on a few key biological constraints.&lt;/p&gt;

&lt;p&gt;Biologically plausible algorithms must be formulated in the &lt;strong&gt;online&lt;/strong&gt; (or streaming), rather than 
offline (or batch), setting. This means that input data are streamed to the algorithm 
sequentially, one sample at a time, and the corresponding output must be computed before 
the next input sample arrives. The output communicated to downstream neurons cannot be 
modified in the future. A neuron cannot store individual past inputs or outputs except in a 
highly compressed format limited to synaptic weights and a few state variables.&lt;/p&gt;

&lt;p&gt;In biologically plausible NNs, learning rules must be &lt;strong&gt;local&lt;/strong&gt;. This means that the synaptic weight 
update may depend on the activities of only the two neurons a synapse connects, as for 
example, in Hebbian learning. Activities of other neurons are not physically available to a 
synapse and therefore including them into learning rules would be biologically
implausible. Modern artificial NNs, such as 
backpropagation-based deep learning networks, rely on nonlocal learning rules.&lt;/p&gt;

&lt;p&gt;Our initial focus is on &lt;strong&gt;unsupervised&lt;/strong&gt; learning. This is not a hard constraint, but rather a matter of 
priority. Whereas humans are clearly capable of supervised learning, most of our learning tasks 
lack big labeled datasets. On the mechanistic level, most neurons lack a clear supervision signal.&lt;/p&gt;

&lt;h2 id=&quot;single-neuron-online-principal-component-analysis-pca&quot;&gt;Single-neuron Online Principal Component Analysis (PCA)&lt;/h2&gt;

&lt;p&gt;In 1982, &lt;a href=&quot;https://pdfs.semanticscholar.org/38bc/c5d342accf5249514cdfdaaa40871a93252c.pdf&quot;&gt;Oja proposed&lt;/a&gt;
modeling a neuron by an online PCA algorithm. PCA is a workhorse of data
analysis used for dimensionality reduction, denoising, and latent factor 
discovery. Therefore, Oja’s seminal paper established that biological processes in 
a neuron can be viewed as the steps of an online algorithm solving a useful 
computational objective.&lt;/p&gt;

&lt;p&gt;Oja’s single-neuron online PCA algorithm works as follows. At each time step, $t$, 
it receives an input data sample, ${\bf x_t}$, computes and outputs 
the corresponding top principal component value, $y_t$:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;y_t \leftarrow {\bf w} _{t-1}^\top {\bf x}_t. \qquad \qquad \qquad (1.1)&lt;/script&gt;

&lt;p&gt;Here and below lowercase boldfaced letters designate vectors. Then the algorithm updates the 
(normalized) feature vector,&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;{\bf w} _t \leftarrow {\bf w} _{t-1}+ \eta ( {\bf x} _t- {\bf w} _{t-1} y_t  ) y_t. \qquad \qquad (1.2)&lt;/script&gt;

&lt;p&gt;The feature vector, ${\bf w}$, converges to the eigenvector of input covariance if data are drawn i.i.d from 
a stationary distribution.&lt;/p&gt;

&lt;p&gt;The steps of the Oja algorithm (1.1-1.2) correspond to the operations of the biological neuron. If the 
input vector is represented by the activities of the upstream neurons, (1.1) represents weighted 
summation of the inputs by the output neuron. If the activation function is linear the output, $y_t$,
is simply the weighted sum. The update (1.2) is a local Hebbian synaptic learning rule. The 
first term of the update is proportional to the correlation of the pre- and postsynaptic neurons’ 
activities and the second term, also local, normalizes the synaptic weight vector.&lt;/p&gt;

&lt;h2 id=&quot;a-normative-theory&quot;&gt;A Normative Theory&lt;/h2&gt;

&lt;p&gt;Next, we would like to build on Oja’s insightful identification of biological 
processes with the steps of the online PCA algorithm by computing multiple 
principal components using multi-neuron NNs and including the activation nonlinearity.&lt;/p&gt;

&lt;p&gt;Instead of trying to extend the Oja model heuristically, we take a more 
systematic, so-called normative approach. In this approach, a biological 
model is viewed as the solution of an optimization problem. Specifically, we 
postulate an objective function motivated by a computational principle, 
derive an online algorithm optimizing such objective, and map the steps 
of the algorithm onto biological processes.&lt;/p&gt;

&lt;p&gt;Having such normative theory allows us to navigate through the space of 
possible algorithmic models in a more efficient and systematic way. Mathematical
compactness of objective functions facilitates generating new models and 
weeding out inconsistent ones. This is similar to the Hamiltonian approach
in physics which leverages natural symmetries and safeguards against the violation
of the first law of thermodynamics (energy conservation).&lt;/p&gt;

&lt;h2 id=&quot;deriving-a-single-neuron-online-pca-using-the-reconstruction-approach&quot;&gt;Deriving a Single-neuron Online PCA using the Reconstruction Approach&lt;/h2&gt;

&lt;p&gt;To build a normative theory, we first need to derive Oja’s single-neuron online algorithm by 
solving an optimization problem. What objective function should we choose for online PCA? 
Historically, neural activity has been often viewed as representing each data sample, ${\bf x}_t$, by the 
feature vector, ${\bf w}$, scaled by the output, $y_t$, Figure 2. Such reconstruction approach is naturally 
formalized as the minimization of the reconstruction (or coding) error:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\min_{\| {\bf w} \|=1} {\sum \limits_{t=1}^{T} \min_{ y_t} {\| {\bf x}_t-{\bf w} y_t \| ^2_2}}. \qquad \qquad \qquad \quad (1.3)&lt;/script&gt;

&lt;p&gt;In the offline setting, optimization problem (1.3) is solved by PCA: the optimum ${\bf w}$  is the 
eigenvector of input covariance corresponding to the top eigenvalue and the optimum output, $y$, is the first principal component.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://docs.google.com/uc?export=download&amp;amp;id=0B5Pfjcu55RQQaUtLTmFmbjZ3eWs&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Figure 2. PCA represents data samples (circles) by their projections (red) onto the top 
eigenvector, ${\bf w}$. These projections constitute the top principal component. Objective (1.3) 
minimizes the reconstruction error (blue).&lt;/p&gt;

&lt;p&gt;In the online setting, (1.3) can be solved by alternating minimization, which has been a subject 
of &lt;a href=&quot;http://www.offconvex.org/2016/05/08/almostconvexitySATM/&quot;&gt;recent analysis&lt;/a&gt;. After the arrival of each data point, &lt;script type=&quot;math/tex&quot;&gt;{\bf x}_t&lt;/script&gt; , the algorithm computes optimum 
output, $y_t$, while keeping the feature vector, ${\bf w}_{t-1}$, computed at the previous time step, fixed. 
By using calculus, one finds that the optimum output is given by (1.1). Then, the algorithm 
minimizes the total reconstruction error with respect to the feature vector while keeping all the 
outputs fixed. Again, resorting to calculus, one finds (1.2).&lt;/p&gt;

&lt;p&gt;Thus, the single-neuron online PCA algorithm may be derived using the reconstruction approach. To 
compute multiple principal components, we need to extend this success to multi-neuron 
networks.&lt;/p&gt;

&lt;h2 id=&quot;the-reconstruction-approach-fails-for-multi-neuron-networks&quot;&gt;The Reconstruction Approach Fails for Multi-neuron Networks&lt;/h2&gt;

&lt;p&gt;Though the reconstruction approach yields a multi-component online PCA 
algorithm, the corresponding NNs are &lt;em&gt;not&lt;/em&gt; biologically plausible.&lt;/p&gt;

&lt;p&gt;Extension of the reconstruction error objective from single to multiple output components is 
straightforward - each scalar, $y_t$, is replaced by a vector, ${\bf y}_t$:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\min_{\rm diag({\bf W}^\top {\bf W})={\bf I}} {\sum \limits_{t=1}^{T} \min_{ {\bf y}_t} {\| {\bf x}_t-{\bf W} {\bf y}_t \| ^2_2}}. \qquad \qquad \qquad \quad (1.4)&lt;/script&gt;

&lt;p&gt;Here matrix ${\bf W}$ comprises column-vectors corresponding to different features. As in the single-
neuron case this objective can be optimized online by alternating minimization. After the arrival 
of data sample, ${\bf x}_t$, the feature vectors are kept fixed while the objective (1.4) is minimized 
with respect to the principal components by iterating the following update until convergence:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;{\bf y}_t \leftarrow {\bf W} _{t-1}^\top {\bf x}_t - {\bf W} _{t-1}^\top {\bf W} _{t-1} {\bf y}_t . \qquad \qquad \qquad (1.5)&lt;/script&gt;

&lt;p&gt;Minimizing the total objective with respect to the feature vectors for fixed principal 
components yields the following update:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;{\bf W} _t \leftarrow {\bf W} _{t-1}+ \eta ( {\bf x} _t- {\bf W} _{t-1} {\bf y}_t ) {\bf y}_t^\top  \cdot \qquad \qquad (1.6)&lt;/script&gt;

&lt;p&gt;As before, in NN implementations of algorithm (1.5-1.6), feature vectors are represented by 
synaptic weights and principal components by the activities of output neurons. Then (1.5) can 
be implemented by a single-layer NN, Figure 3, in which activity dynamics converges 
faster than the time interval between the arrival of successive data samples.&lt;/p&gt;

&lt;p&gt;However, implementing update (1.6) in the single-layer NN architecture, Figure 3, requires 
nonlocal learning rules making it biologically implausible. Indeed, the last term in (1.6) implies 
that updating the weight of a synapse requires the knowledge of output activities of all other 
neurons which are not available to the synapse. Moreover, the matrix of lateral connection 
weights, $- {\bf W} _{t-1}^\top {\bf W} _{t-1}$, in the last term of (1.5) is computed as a Grammian of feedforward weights, 
clearly a nonlocal operation. This problem is not limited to PCA and arises in networks of 
nonlinear neurons as well.&lt;/p&gt;

&lt;p&gt;Rather than deriving learning rules from a principled objective, many authors 
constructed biologically plausible single-layer networks using local learning 
rules, Hebbian for feedforward and anti-Hebbian (meaning there is a minus sign 
in front of the correlation-based synaptic weight as for the last term in (1.5)). 
However, in my view, abandoning the normative approach creates more problems 
than it solves.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://docs.google.com/uc?export=download&amp;amp;id=0B5Pfjcu55RQQMlRNVDVBRDJ0TEk&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Figure 3. The single-layer NN implementation of the multi-neuron online PCA algorithm derived 
using the reconstruction approach requires nonlocal learning rules.&lt;/p&gt;

&lt;p&gt;I have outlined how the conventional reconstruction approach fails to generate 
biologically plausible multi-neuron networks for online PCA. In the next post, 
I will introduce an alternative approach that overcomes this limitation. 
Moreover, this approach suggests a novel view of neural computation leading to 
many interesting extensions.&lt;/p&gt;

&lt;p&gt;(&lt;em&gt;Acknowledgement: I am grateful to Sanjeev Arora for his support and encouragement as well as to Cengiz Pehlevan, Leo Shklovskii, Emily Singer, and Thomas Lin for their comments on the earlier versions.&lt;/em&gt;)&lt;/p&gt;
</description>
        <pubDate>Thu, 03 Nov 2016 03:00:00 -0700</pubDate>
        <link>http://offconvex.github.io/2016/11/03/MityaNN1/</link>
        <guid isPermaLink="true">http://offconvex.github.io/2016/11/03/MityaNN1/</guid>
      </item>
     
    
     
      <item>
        <title>Gradient Descent Learns Linear Dynamical Systems</title>
        <description>&lt;p&gt;From text translation to video captioning, learning to map one sequence to another is an increasingly active research area in machine learning. Fueled by the success of recurrent neural networks in its many variants, the field has seen rapid advances over the last few years. Recurrent neural networks are typically trained using some form of stochastic gradient descent combined with backpropagation for computing derivatives. The fact that gradient descent finds a useful set of parameters is by no means obvious. The training objective is typically non-convex. The fact that the model is allowed to maintain state is an additional obstacle that makes training of recurrent neural networks challenging.&lt;/p&gt;

&lt;p&gt;In this post, we take a step back to reflect on the mathematics of recurrent neural networks. Interpreting recurrent neural networks as dynamical systems, we will show that stochastic gradient descent successfully learns the parameters of an unknown &lt;em&gt;linear&lt;/em&gt; dynamical system even though the training objective is non-convex. Along the way, we’ll discuss several useful concepts from control theory, a field that has studied linear dynamical systems for decades. Investigating stochastic gradient descent for learning linear dynamical systems not only bears out interesting connections between machine learning and control theory, it might also provide a useful stepping stone for a deeper undestanding of recurrent neural networks more broadly.&lt;/p&gt;

&lt;h2 id=&quot;linear-dynamical-systems&quot;&gt;Linear dynamical systems&lt;/h2&gt;

&lt;p&gt;We focus on time-invariant single-input single-output system. For an input sequence of real numbers $x_1,\dots, x_T\in \mathbb{R}$,  the system maintains a sequence of hidden states $h_1,\dots, h_T\in \mathbb{R}^n$, and produces a sequence of outputs $y_1,\dots, y_T\in \mathbb{R}$ according to the following rules:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;h_{t+1} = Ah_t + Bx_t~~~~~~~~~~~~~~~~~~~~~&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\quad \quad\quad~y_t = Ch_t+Dx_t+\xi_t              ~~~~~~~~~~~~~~~~(1)&lt;/script&gt;

&lt;p&gt;Here $A,B,C,D$ are linear transformations with compatible dimensions, and $\xi_t$ is Gaussian noise added to the output at each time. In the learning problem, often called system identification in control theory, we observe samples of input-output pairs $((x_1,\dots, x_T),(y_1,\dots y_T))$ and aim to recover the parameters of the underlying linear system.&lt;/p&gt;

&lt;p&gt;Although control theory provides a rich set of techniques for identifying and manipulating linear systems, maximum likelihood estimation with stochastic gradient descent remains a popular heuristic.&lt;/p&gt;

&lt;p&gt;We denote by $\Theta = (A,B,C,D)$ the parameters of the true system. We parametrize our model with $\widehat{\Theta} = (\hat{A},\hat{B},\hat{C},\hat{D})$, and the trained model maintains hidden states $\hat{h}_t$ and outputs $\hat{y}_t$ exactly as in equation (1). For each given example $(x,y) = ((x_1,\dots,x_T), (y_1,\dots, y_t))$, the log-likelihood of model $\widehat{\Theta}$ is 
&lt;script type=&quot;math/tex&quot;&gt;f(\widehat{\Theta}, (x,y)) = \frac{1}{T}\sum_{t=1}^{T}\left\|y_t-\hat{y}_t\right\|^2&lt;/script&gt;. The population risk is defined as the expected log-likelihood,&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;f(\widehat{\Theta}) =  \mathbb{E}_{(x,y)} \left[f(\widehat{\Theta}, (x,y))\right]&lt;/script&gt;

&lt;p&gt;Stochastic gradients of the population risk can be computed in time $O(Tn)$ via back-propagation given random samples. We can therefore directly minimize population risk using stochastic gradient descent. The question is just whether the algorithm actually converges. Even though the state transformations are linear, the objective function we defined is not convex. Luckily, we will see that the objective is still &lt;em&gt;close enough&lt;/em&gt; to convex for stochastic gradient to make steady progress towards the global minimum.&lt;/p&gt;

&lt;h2 id=&quot;hair-dryers-and-quasi-convex-functions&quot;&gt;Hair dryers and quasi-convex functions&lt;/h2&gt;

&lt;p&gt;Before we go into the math, let’s illustrate the algorithm with a pressing example that we all run into every morning: hair drying. Imagine you have a hair dryer with a &lt;em&gt;low&lt;/em&gt; temperature setting and a &lt;em&gt;high&lt;/em&gt; temperature setting. Neither setting is ideal. So every morning you switch between the settings frantically in an attempt to modulate to the ideal temperature. Measuring the resulting temperature (red line below) as a function of the input setting (green dots below), the picture you’ll see is something like &lt;a href=&quot;https://www.mathworks.com/help/ident/examples/estimating-simple-models-from-real-laboratory-process-data.html?prodcode=ML&quot;&gt;this&lt;/a&gt;:&lt;/p&gt;

&lt;div style=&quot;text-align:center;&quot;&gt;
   &lt;img style=&quot;width:800px;&quot; src=&quot;/assets/sysid/dryer/dryer-0.svg&quot; /&gt;
  &lt;/div&gt;

&lt;p&gt;You can see that the output temperature is related to the inputs. If you set the temperature to high for long enough, you’ll eventually get a high output temperature. But the system has state. Briefly lowering the temperature has little effect on the outputs. Intuition suggests that these kind of effects should be captured by a system with two or three hidden states. So, let’s see how SGD would go about finding the parameters of the system. We’ll initialize a system with three hidden states such that before training its predictions are just the inputs of the system. We then run SGD with a fixed learning rate on the same sequence for 400 steps.&lt;/p&gt;

&lt;p&gt;&lt;!-- begin animation --&gt;&lt;/p&gt;
&lt;div style=&quot;text-align:center;&quot;&gt;
   &lt;img style=&quot;width:800px;&quot; id=&quot;imganim&quot; src=&quot;/assets/sysid/dryer/dryer-1.svg&quot; onclick=&quot;forward_image()&quot; /&gt;
  &lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;//&lt;![CDATA[
  var images = [
  &quot;/assets/sysid/dryer/dryer-1.svg&quot;,
  &quot;/assets/sysid/dryer/dryer-2.svg&quot;,
  &quot;/assets/sysid/dryer/dryer-3.svg&quot;,
  &quot;/assets/sysid/dryer/dryer-4.svg&quot;,
  &quot;/assets/sysid/dryer/dryer-5.svg&quot;,
  &quot;/assets/sysid/dryer/dryer-6.svg&quot;,
  &quot;/assets/sysid/dryer/dryer-7.svg&quot;,
  &quot;/assets/sysid/dryer/dryer-8.svg&quot;,
  ]
  var iC = 0
  function forward_image(){
   iC = iC + 1;
   document.getElementById('imganim').src = images[iC%8];
   document.getElementById('counter').textContent = 50* (iC%8);
  }
  //]]&gt; 
  &lt;/script&gt;

&lt;p&gt;&lt;!-- end animation --&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;The blue line shows the predictions of SGD after &lt;span style=&quot;font-family:monospace;&quot;&gt;&lt;span id=&quot;counter&quot;&gt;0&lt;/span&gt;/400&lt;/span&gt; gradient updates. Click to advance.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Evidently, gradient descent converges just fine on this example. Let’s look at the hair dryer objective function along the line segment between two random points in the domain.&lt;/p&gt;

&lt;div style=&quot;text-align:center;&quot;&gt; 
&lt;img src=&quot;/assets/sysid/dryer-segment.svg&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;The function is clearly not convex, but it doesn’t look too bad either. In particular, from the picture, it could be that the objective function is &lt;em&gt;quasi-convex&lt;/em&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Definition:&lt;/strong&gt; For $\tau &amp;gt; 0$, a function $f(\theta)$ is $\tau$-quasi-convex with respect to a global minimum $\theta ^ * $ if for every $\theta$,
&lt;script type=&quot;math/tex&quot;&gt;\langle \nabla f(\theta), \theta - \theta^* \rangle \ge \tau (f(\theta)-f(\theta^*)).&lt;/script&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Intuitively, quasi-convexity states that the descent direction $-\nabla f(\theta)$ is positively correlated with the ideal moving direction $\theta^* -\theta$. This implies that the potential function $\left|\theta-\theta ^ *  \right|^2$ decreases in expectation at each step of stochastic gradient descent. This observation plugs nicely into the standard SGD analysis, leading to the following result:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Proposition:&lt;/strong&gt; (informal) Suppose the population risk $f(\theta)$ is $\tau$-quasi-convex, then stochastic gradient descent (with fresh samples at each iteration and proper learning rate) converges to a point $\theta_K$ in $K$ iterations with error bounded by 
$ f(\theta_K) - f(\theta^*) \leq O(1/(\tau \sqrt{K}))$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The key challenge for us is to understand under what conditions we can prove that the population risk objective is in fact quasi-convex. This requires some background.&lt;/p&gt;

&lt;h2 id=&quot;control-theory-polynomial-roots-and-pac-man&quot;&gt;Control theory, polynomial roots, and Pac-Man&lt;/h2&gt;

&lt;p&gt;A linear dynamical system $(A,B,C,D)$ is equivalent to the system $(TAT^{-1}, TB, CT^{-1}, D)$ for any invertible matrix $T$ in terms of the behavior of the outputs. A little thought shows therefore that in its unrestricted parameterization the objective function cannot have a unique optimum. A common way of removing this redundancy is to impose a canonical form. Almost all non-degenerate system admit the &lt;em&gt;controllable canonical form&lt;/em&gt;, defined as&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
A\; = \;
    \left[ \begin{array}{ccccc} 0 &amp; 1 &amp; 0 &amp; \cdots &amp; 0 \newline 0 &amp; 0 &amp; 1 &amp; \cdots &amp; 0 \newline
    \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \newline 0 &amp; 0 &amp; 0 &amp; \cdots &amp; 1 \newline
    -a_n &amp; -a_{n-1} &amp; -a_{n-2} &amp; \cdots &amp; -a_1 \end{array} \right]
\qquad 
B = \left[ \begin{array}{c} 0\newline 0 \newline\vdots \newline 0 \newline 1 \end{array} \right] %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
C\;~= \;
    \left[ \begin{array}{ccccc} c_1~~~~&amp; c_2~~~~ &amp; c_3~~~~&amp; ~~\cdots\cdots~~~~&amp; c_n \end{array} \right]
\qquad 
D =~~ \left[ \begin{array}{c} d\end{array} \right] %]]&gt;&lt;/script&gt;

&lt;p&gt;We will also parametrize our training model using these forms. One of its nice properties is that the coefficients of the characteristic polynomial of the &lt;em&gt;state transition matrix&lt;/em&gt; $A$ can be read off from the last row of $A$. That is, 
&lt;script type=&quot;math/tex&quot;&gt;det(zI-A) = p_a(z) := z^n+a_1z^{n-1}+\dots + a_n.&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Even in controllable canonical form, it still seems rather difficult to learn arbitrary linear dynamical systems. A natural restriction would be &lt;em&gt;stability&lt;/em&gt;, that is, to require that the eigenvalues of $A$ are all bounded by $1.$ Equivalently, the roots of the characteristic polynomial should all be contained in the complex unit disc. Without stability, the state of the system could blow up exponentially making robust learning difficult. But the set of all stable systems forms a non-convex domain. It seems daunting to guarantee that stochastic gradient descent would converge from an arbtirary starting point in this domain without ever leaving the domain.&lt;/p&gt;

&lt;p&gt;We will therefore impose a stronger restriction on the roots of the characteristic polynomial. We call this the Pac-Man condition. You can think of it as a strengthening of stability.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Pac-Man condition&lt;/strong&gt;: A linear dynamical system in controllable canonical form satisfies the Pac-Man condition if the coefficient vector $a$ defining the state transition matrix satisfies
&lt;script type=&quot;math/tex&quot;&gt;|Re(q_a(z))| &gt; |Im(q_a(z))|&lt;/script&gt; for all complex numbers $z$ of modulus $|z| = 1$, where $q_a(z) = p_a(z)/z^n = 1+a_1z^{-1}+\dots + a_nz^{-n}$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div style=&quot;text-align:center;&quot;&gt;
 &lt;img style=&quot;width:350px;margin-bottom:50px;&quot; src=&quot;/assets/sysid/pacman.png&quot; /&gt;
 &lt;img style=&quot;width:400px;&quot; src=&quot;/assets/sysid/trace-degree4.png&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Above, we illustrate this condition for a degree 4 system plotting the value of $q_a(z)$ on complex plane for all complex numbers $z$ on the unit circle.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;We note that Pac-Man condition is satisfied by vectors $a$ with $|a|_1\le \sqrt{2}/2$. Moreover, if $a$ is a random Gaussian vector with expected $\ell_2$ norm bounded by $o(1/\sqrt{\log n})$, then it will satisfy Pac-Man condition with probability $1-o(1)$. Roughly speaking, the assumption requires the roots of the characteristic polynomial $p_a(z)$ are relatively dispersed inside the unit circle.&lt;/p&gt;

&lt;p&gt;The Pac-Man condition has three important implications:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;It implies via &lt;a href=&quot;https://en.wikipedia.org/wiki/Rouch%C3%A9%27s_theorem&quot;&gt;Rouche’s theorem&lt;/a&gt; that the spectral radius of A is smaller than 1 and therefore ensures stability of the system.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The vectors satisfying it form a convex set in $\mathbb{R}^n$.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Finally, it ensures that the objective function is &lt;em&gt;quasi-convex&lt;/em&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;main-result&quot;&gt;Main result&lt;/h2&gt;

&lt;p&gt;Relying on the Pac-Man condition, we can show:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Main theorem (Hardt, Ma, Recht, 2016)&lt;/strong&gt;: Under the Pac-Man condition, projected gradient descent algorithm, given $N$ sample sequences of length $T$, returns parameters $\widehat{\Theta}$ with population risk 
&lt;script type=&quot;math/tex&quot;&gt;f(\widehat{\Theta}) \le f(\Theta) + poly(n)/\sqrt{NT}.&lt;/script&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The theorem sorts out the right dependence on $N$ and $T$. Even if there is only one sequence, we can learn the system provided that the sequence is long enough. Similarly, even if sequences are really short, we can learn provided that there are enough sequences.&lt;/p&gt;

&lt;h2 id=&quot;quasi-convexity-in-the-frequency-domain&quot;&gt;Quasi-convexity in the frequency domain&lt;/h2&gt;

&lt;p&gt;To establish quasi-convexity under the Pac-Man condition, we will first develop an explicit formula for the population risk in frequency domain. In doing so, we assume that  $x_1,\dots, x_T$ are pairwise independent with mean 0 and variance 1. We also consider the population risk as $T\rightarrow \infty$ for simplicity in this post.&lt;/p&gt;

&lt;p&gt;A simple algebraic manipulation simplifies the population risk with infinite sequence length to&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\lim_{T \rightarrow \infty} f(\widehat{\Theta}) = (\hat{D}-D)^2 + \sum_{k=0}^{\infty} (\hat{C}\hat{A}^kB-CA^k B)^2.&lt;/script&gt;

&lt;p&gt;The first term, $(\hat D - D)^2$ is convex and appears nowhere else. We can safely ignore it and focus on the remaining expression instead, which we call the &lt;em&gt;idealized risk&lt;/em&gt;:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;g(\widehat{\Theta}) = \sum_{k=0}^{\infty} (\hat{C}\hat{A}^kB-CA^k B)^2&lt;/script&gt;

&lt;p&gt;To deal with the sequence $\hat{C}\hat{A}^kB$, we take its Fourier transform and obtain that&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\hat{C}\hat{A}^kB, k\ge 1 ~~~~\longrightarrow ~~~~~~~\widehat{G}_{\lambda} =  \frac{\hat{c}_1e^{(n-1)\lambda}+\dots+ \hat{c}_n}{e^{n\lambda} + \hat{a}_1e^{(n-1)\lambda}+\dots+\hat{a}_n}, \lambda\in [0,2\pi]&lt;/script&gt;

&lt;p&gt;Similarly we take the Fourier transform of $CA^kB$, denoted by $G_{\lambda}$. Then by Parseval’s Theorem, we obtain the following alternative representation of the population risk,&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;f(\widehat{\Theta}) = \int_{0}^{2\pi} |G_{\lambda}-\widehat{G}_{\lambda}|^2 d\lambda.&lt;/script&gt;

&lt;p&gt;Mapping out $G_\lambda$ and $\widehat G_\lambda$ for all $\lambda\in [0, 2\pi]$ gives the following picture:&lt;/p&gt;

&lt;div style=&quot;text-align:center;&quot;&gt;
   &lt;img style=&quot;width:400px;&quot; src=&quot;/assets/sysid/transfer/approx-10.png&quot; onclick=&quot;forward_transfer_image()&quot; /&gt;
   &lt;img style=&quot;width:400px;&quot; id=&quot;transfer-img&quot; src=&quot;/assets/sysid/transfer/approx-00.png&quot; onclick=&quot;forward_transfer_image()&quot; /&gt;
 &lt;/div&gt;

&lt;script type=&quot;text/javascript&quot;&gt;//&lt;![CDATA[
  var transfer_images = [
  &quot;/assets/sysid/transfer/approx-00.png&quot;,
  &quot;/assets/sysid/transfer/approx-01.png&quot;,
  &quot;/assets/sysid/transfer/approx-02.png&quot;,
  &quot;/assets/sysid/transfer/approx-03.png&quot;,
  &quot;/assets/sysid/transfer/approx-04.png&quot;,
  &quot;/assets/sysid/transfer/approx-05.png&quot;,
  &quot;/assets/sysid/transfer/approx-06.png&quot;,
  &quot;/assets/sysid/transfer/approx-07.png&quot;,
  &quot;/assets/sysid/transfer/approx-08.png&quot;,
  &quot;/assets/sysid/transfer/approx-09.png&quot;,
  &quot;/assets/sysid/transfer/approx-10.png&quot;,
  ]
  var iA = 0
  function forward_transfer_image(){
   iA = iA + 1;
   document.getElementById('transfer-img').src = transfer_images[iA%11];
   document.getElementById('transfer-counter').textContent = (iA%11);
  }
  //]]&gt; 
  &lt;/script&gt;

&lt;p&gt;&lt;em&gt;Left: Target transfer function $G$. Right: Approximation $\widehat G$ at step &lt;span style=&quot;font-family:monospace&quot; id=&quot;transfer-counter&quot;&gt;0&lt;/span&gt;/10. Click to advance.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Given this pretty representation of the idealized risk objective, we can finally prove our main lemma.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Lemma:&lt;/strong&gt;  Suppose $\Theta$ satisfies the Pac-Man condition. Then, 
for every $0\le \lambda\le 2\pi$, $|G_{\lambda}-\widehat{G}_{\lambda}|^2$, 
as a function of $\hat{A},\hat{C}$ is quasi-convex in the Pac-Man region.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The lemma reduces to the following simple claim.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Claim:&lt;/strong&gt; The function $h(\hat{u},\hat{v}) = |\hat{u}/\hat{v} - u/v|^2$ is quasi-convex in the region where $Re(\hat{v}/v) &amp;gt; 0$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The proof simply involves computing the gradients and checking the conditions for quasi-convexity by elementary algebra. We omit a formal proof, but intead show a plot of the function $h(\hat{u}, \hat{v}) = (\hat{u}/\hat{v}- 1)^2$ over the reals:&lt;/p&gt;

&lt;p&gt;&lt;!-- begin animation --&gt;&lt;/p&gt;
&lt;div style=&quot;text-align:center;&quot;&gt;
   &lt;img style=&quot;height:600px&quot; id=&quot;3dplot-img&quot; src=&quot;/assets/sysid/3dplot/3dplot-30.jpg&quot; onclick=&quot;forward_3dplot_image()&quot; /&gt;
   &lt;p style=&quot;text-align:center;&quot;&gt; Click to rotate.&lt;/p&gt;
  &lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;//&lt;![CDATA[
  var plot3d_images = [
  &quot;/assets/sysid/3dplot/3dplot-0.jpg&quot;,
  &quot;/assets/sysid/3dplot/3dplot-10.jpg&quot;,
  &quot;/assets/sysid/3dplot/3dplot-20.jpg&quot;,
  &quot;/assets/sysid/3dplot/3dplot-30.jpg&quot;,
  &quot;/assets/sysid/3dplot/3dplot-40.jpg&quot;,
  &quot;/assets/sysid/3dplot/3dplot-50.jpg&quot;,
  &quot;/assets/sysid/3dplot/3dplot-60.jpg&quot;,
  &quot;/assets/sysid/3dplot/3dplot-70.jpg&quot;,
  &quot;/assets/sysid/3dplot/3dplot-80.jpg&quot;,
  &quot;/assets/sysid/3dplot/3dplot-90.jpg&quot;,
  ]
  var iB = 3
  var inc_sign = 1
  function forward_3dplot_image(){
   iB = iB + inc_sign;
   if (iB == 9) {
     inc_sign = -1;
   }
   if (iB == 0) {
     inc_sign = 1;
   }
   document.getElementById('3dplot-img').src = plot3d_images[iB];
  }
  //]]&gt; 
  &lt;/script&gt;

&lt;p&gt;&lt;!-- end animation --&gt;&lt;/p&gt;

&lt;p&gt;To see how the lemma follows from the previous claim we note that quasi-convexity is preserved under composition with any linear transformation. Specifically, $h(z)$ is quasi-convex, then $h(R x)$ is also quasi-convex for any linear map $R$. So, consider the linear map:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(\hat{a},\hat{c})\mapsto (\hat u, \hat v) = (\hat{c}_1e^{(n-1)\lambda}+\dots+ \hat{c}_n, e^{n\lambda} 
+\hat{a}_1e^{(n-1)\lambda}+\dots+\hat{a}_n)&lt;/script&gt;

&lt;p&gt;With this linear transformation, our simple claim about a bivariate function extends to show that $(G_{\lambda}-\widehat{G}_{\lambda})^2$ is quasi-convex when $Re(\hat{v}/v) \ge 0$. In particular, when $\hat{a}$ and $a$ both satisfy the Pac-Man condition,  then $\hat{v}$ and $v$ both reside in the 90 degree wedge. Therefore they have an angle smaller than 90 degree. This implies that $Re(\hat{v}/v) &amp;gt; 0$.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;We saw conditions under which stochastic gradient descent successfully learns a linear dynamical system. In &lt;a href=&quot;https://arxiv.org/abs/1609.05191&quot;&gt;our paper&lt;/a&gt;, we further show that allowing our learned system to have more parameters than the target system makes the problem dramatically easier. In particular, at the expense of slight over-parameterization we can weaken the Pac-Man condition to a mild separation condition on the roots of the characteristic polynomial. This is consistent with empirical observations both in machine learning and control theory that highlight the effectiveness of additional model parameters.&lt;/p&gt;

&lt;p&gt;More broadly, we hope that our techniques will be a first stepping stone toward a better theoretical understanding of recurrent neural networks.&lt;/p&gt;
</description>
        <pubDate>Thu, 13 Oct 2016 03:00:00 -0700</pubDate>
        <link>http://offconvex.github.io/2016/10/13/gradient-descent-learns-dynamical-systems/</link>
        <guid isPermaLink="true">http://offconvex.github.io/2016/10/13/gradient-descent-learns-dynamical-systems/</guid>
      </item>
     
    
     
      <item>
        <title>Linear algebraic structure of word meanings</title>
        <description>&lt;p&gt;Word embeddings capture the meaning of a word using a low-dimensional vector and are ubiquitous in natural language processing (NLP). (See my  earlier &lt;a href=&quot;http://www.offconvex.org/2015/12/12/word-embeddings-1/&quot;&gt;post 1&lt;/a&gt;
and &lt;a href=&quot;http://www.offconvex.org/2016/02/14/word-embeddings-2/&quot;&gt;post2&lt;/a&gt;.) It has always been unclear how to interpret the embedding when the word in question is &lt;em&gt;polysemous,&lt;/em&gt; that is, has multiple senses. For example, &lt;em&gt;tie&lt;/em&gt; can mean an article of clothing, a drawn sports match, and a physical action.&lt;/p&gt;

&lt;p&gt;Polysemy is an important issue in NLP  and much work relies upon &lt;a href=&quot;https://wordnet.princeton.edu/&quot;&gt;WordNet&lt;/a&gt;, a hand-constructed repository of word senses and their interrelationships. Unfortunately, good WordNets do not exist for most languages, and even the one in English  is believed to be rather incomplete. Thus some effort has been spent on methods to find different senses of words.&lt;/p&gt;

&lt;p&gt;In this post I will talk about &lt;a href=&quot;https://arxiv.org/abs/1601.03764&quot;&gt;my joint work with Li, Liang, Ma, Risteski&lt;/a&gt; which shows that actually word senses are easily accessible in many current word embeddings. This goes against conventional wisdom in NLP, which is that &lt;em&gt;of course&lt;/em&gt;, word embeddings do not suffice to capture polysemy since they use a single vector to represent the word, regardless of whether the word has one sense, or a dozen.  Our work shows that major senses of the word lie in linear superposition within the embedding, and are extractable using sparse coding.&lt;/p&gt;

&lt;p&gt;This post uses embeddings constructed using our method and the wikipedia corpus, but similar techniques also apply (with some loss in precision) to  other embeddings described in &lt;a href=&quot;http://www.offconvex.org/2015/12/12/word-embeddings-1/&quot;&gt;post 1&lt;/a&gt; such as word2vec, Glove, or even the decades-old PMI embedding.&lt;/p&gt;

&lt;h2 id=&quot;a-surprising-experiment&quot;&gt;A surprising experiment&lt;/h2&gt;

&lt;p&gt;Take the viewpoint –simplistic yet instructive– that a polysemous word like &lt;em&gt;tie&lt;/em&gt; is a single lexical token that represents unrelated words &lt;em&gt;tie1&lt;/em&gt;, &lt;em&gt;tie2&lt;/em&gt;, …
Here is a surprising experiment that suggests that the embedding for &lt;em&gt;tie&lt;/em&gt; should be approximately a weighted sum of the (hypothethical) embeddings of &lt;em&gt;tie1&lt;/em&gt;, &lt;em&gt;tie2&lt;/em&gt;, …&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Take two random  words $w_1, w_2$. Combine them into an artificial polysemous word $w_{new}$ by replacing every occurrence of $w_1$ or $w_2$ in the corpus by $w_{new}.$ Next, compute an embedding for $w_{new}$ using the same embedding method while deleting embeddings for $w_1, w_2$ but preserving the embeddings for all other words. Compare the embedding $v_{w_{new}}$ to linear combinations of $v_{w_1}$ and
$v_{w_2}$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Repeating this experiment with a wide range of values for the ratio $r$ between the frequencies of $w_1$ and $w_2$, we find that $v_{w_{new}}$ lies close to the subspace spanned by $v_{w_1}$ and $v_{w_2}$: the cosine of its angle with the subspace  is on average $0.97$ with standard deviation $0.02$. Thus  $v_{w_{new}} \approx \alpha v_{w_1} + \beta v_{w_2}$. 
We find that $\alpha \approx 1$ whereas  $\beta \approx 1- c\lg r$
 for some constant $c\approx 0.5$. (Note this formula is meaningful when the frequency ratio $r$ is not too large, i.e. when $ r &amp;lt; 10^{1/c} \approx 100$.) Thanks to this logarithm, the infrequent sense is not swamped out in the embedding, even if it is 50 times less frequent than the dominant sense. This is an important reason behind the success of our method for extracting word senses.&lt;/p&gt;

&lt;p&gt;This experiment –to which we were led by our theoretical investigations– is very surprising 
because the embedding is the solution to a complicated, nonconvex optimization, yet it behaves in such a striking linear way. You can read our paper for an intuitive explanation using our theoretical model from &lt;a href=&quot;http://www.offconvex.org/2016/02/14/word-embeddings-2/&quot;&gt;post2&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;extracting-word-senses-from-embeddings&quot;&gt;Extracting word senses from embeddings&lt;/h2&gt;

&lt;p&gt;The above experiment suggests that&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;v_{tie} \approx \alpha_1 \cdot v_{ tie1} + \alpha_2 \cdot v_{tie2} + \alpha_3 \cdot v_{tie3} +\cdots \qquad (1)&lt;/script&gt;

&lt;p&gt;but this alone is insufficient to mathematically pin down the senses, since $v_{tie}$ can be expressed in infinitely many ways as such a combination. To pin down the senses we will interrelate the senses of different words —for example, relate the “article of clothing” sense &lt;em&gt;tie1&lt;/em&gt; with  &lt;em&gt;shoe, jacket&lt;/em&gt; etc.&lt;/p&gt;

&lt;p&gt;The word senses &lt;em&gt;tie1, tie2,..&lt;/em&gt; correspond to “different things being talked about” —in other words, different word distributions occuring around  &lt;em&gt;tie&lt;/em&gt;.
 Now remember that &lt;a href=&quot;http://128.84.21.199/abs/1502.03520v6&quot;&gt;our earlier paper&lt;/a&gt; described in 
 &lt;a href=&quot;http://www.offconvex.org/2016/02/14/word-embeddings-2/&quot;&gt;post2&lt;/a&gt; gives an interpretation of “what’s being talked about”: it is called &lt;em&gt;discourse&lt;/em&gt; and 
 it is represented by a unit vector in the embedding space. In particular, the theoretical model 
 of &lt;a href=&quot;http://www.offconvex.org/2016/02/14/word-embeddings-2/&quot;&gt;post2&lt;/a&gt; imagines a text corpus as being generated by a random walk on 
 discourse vectors. When the walk is at a discourse $c_t$ at time $t$, it outputs a few words using a loglinear distribution:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\Pr[w~\mbox{emitted at time $t$}~|~c_t] \propto \exp(c_t\cdot v_w). \qquad (2)&lt;/script&gt;

&lt;p&gt;One imagines  there exists a “clothing” discourse that has high probability of outputting the &lt;em&gt;tie1&lt;/em&gt; sense, and also of outputting related words such as &lt;em&gt;shoe, jacket,&lt;/em&gt; etc.
Similarly there may be a  “games/matches” discourse that has high probability of outputting  &lt;em&gt;tie2&lt;/em&gt; as well as &lt;em&gt;team, score&lt;/em&gt; etc.&lt;/p&gt;

&lt;p&gt;By equation (2) the probability of being output by a discourse is determined by the 
inner product, so one expects that the vector  for  “clothing” discourse  has high inner product with all of &lt;em&gt;shoe, jacket, tie1&lt;/em&gt; etc., and thus can stand as surrogate for $v_{tie1}$ in expression (1)!  This motivates the following  global optimization:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Given word vectors in $\Re^d$, totaling  about $60,000$ in this case, a sparsity parameter $k$,
and an upper bound $m$, find a set of unit vectors   $A_1, A_2, \ldots, A_m$  such that
&lt;script type=&quot;math/tex&quot;&gt;v_w = \sum_{j=1}^m\alpha_{w,j}A_j + \eta_w \qquad (3)&lt;/script&gt;
where at most $k$ of the coefficients $\alpha_{w,1},\dots,\alpha_{w,m}$ are nonzero (so-called  &lt;em&gt;hard sparsity constraint&lt;/em&gt;), and $\eta_w$ is a  noise vector.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Here  $A_1, \ldots A_m$ represent important discourses in the corpus, which 
we refer to as  &lt;em&gt;atoms of discourse.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Optimization (3) is a surrogate for the desired expansion of $v_{tie}$ in (1)  because one can hope that the atoms of discourse  will contain atoms corresponding to  &lt;em&gt;clothing&lt;/em&gt;, &lt;em&gt;sports matches&lt;/em&gt; etc. that will have high inner product (close to $1$) with &lt;em&gt;tie1,&lt;/em&gt;  &lt;em&gt;tie2&lt;/em&gt; respectively. Furthermore, restricting $m$ to be much smaller than the number of words ensures that each atom  needs to be used for multiple words, e.g., reuse the “clothing” atom 
for &lt;em&gt;shoes&lt;/em&gt;, &lt;em&gt;jacket&lt;/em&gt; etc. as well as for &lt;em&gt;tie&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Both $A_j$’s and $\alpha_{w,j}$’s are unknowns in this optimization. This is nothing but &lt;em&gt;sparse coding,&lt;/em&gt;  useful in neuroscience, image processing, computer vision,  etc. It is nonconvex and computationally NP-hard in the worst case, but can be solved quite efficiently in practice  using something called the k-SVD algorithm described in &lt;a href=&quot;http://www.cs.technion.ac.il/~elad/publications/others/PCMI2010-Elad.pdf&quot;&gt;Elad’s survey, lecture 4&lt;/a&gt;.  We solved this problem with sparsity
$k=5$ and  using $m$ about $2000$. (Experimental details are in the paper. Also, some theoretical
analysis of such an algorithm is possible; see this &lt;a href=&quot;http://www.offconvex.org/2016/05/08/almostconvexitySATM/&quot;&gt;earlier post&lt;/a&gt;.)&lt;/p&gt;

&lt;h1 id=&quot;experimental-results&quot;&gt;Experimental Results&lt;/h1&gt;

&lt;p&gt;Each discourse atom defines via (2) a distribution on words, which due to the exponential appearing in (2) strongly favors words whose embeddings have a larger inner product with it. In practice, this distribution is quite concentrated on as few as  50-100 words, and the “meaning” of a discourse atom can be roughly determined by looking at a few nearby words. This is how we visualize atoms in the figures below. The first figure gives a few representative atoms of discourse.&lt;/p&gt;

&lt;p style=&quot;text-align:center;&quot;&gt;
&lt;img src=&quot;http://www.cs.princeton.edu/~arora/pubs/discourseatoms.jpg&quot; alt=&quot;A few of the 2000 atoms of discourse found&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;And here are the discourse atoms used to represent two polysemous words, &lt;em&gt;tie&lt;/em&gt; and &lt;em&gt;spring&lt;/em&gt;&lt;/p&gt;

&lt;p style=&quot;text-align:center;&quot;&gt;
&lt;img src=&quot;http://www.cs.princeton.edu/~arora/pubs/atomspolysemy.jpg&quot; alt=&quot;Discourse atoms expressing the words tie and spring.&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;You can see that the discourse atoms do correspond to senses of these words.&lt;/p&gt;

&lt;p&gt;Finally, we also have a technique that, given a target word, generates representative sentences according to its various senses as detected by the algorithm. Below are the sentences returned for
&lt;em&gt;ring.&lt;/em&gt; (N.B. The mathematical meaning was missing in WordNet but was picked up by our method.)&lt;/p&gt;
&lt;p style=&quot;text-align:center;&quot;&gt;
&lt;img src=&quot;http://www.cs.princeton.edu/~arora/pubs/repsentences.jpg&quot; alt=&quot;Representative sentences for different senses of the word ring.&quot; /&gt;
&lt;/p&gt;

&lt;h2 id=&quot;a-new-testbed-for-testing-comprehension-of-word-senses&quot;&gt;A new testbed for testing comprehension of word senses&lt;/h2&gt;

&lt;p&gt;Many tests have been proposed to test an algorithm’s grasp of word senses. They often involve
hard-to-understand metrics such as  distance in WordNet, or sometimes  tied to performance on specific applications like web search.&lt;/p&gt;

&lt;p&gt;We propose a new simple test –inspired by word-intrusion tests for topic coherence
due to &lt;a href=&quot;https://www.umiacs.umd.edu/~jbg/docs/nips2009-rtl.pdf&quot;&gt;Chang et al 2009&lt;/a&gt;– which has the advantages of being easy to understand, and can also be administered to humans.&lt;/p&gt;

&lt;p&gt;We created a testbed using 200 polysemous words and their 704 senses according to WordNet. Each “sense”  is represented by a set of 8 related words; these were collected from WordNet and online dictionaries by college students who were told  to identify  most relevant other words occurring in the online definitions of this word sense as well as in the accompanying illustrative sentences.  These 8 words  are considered as &lt;em&gt;ground truth&lt;/em&gt; representation of the word sense: e.g., for the  “tool/weapon” sense of  &lt;em&gt;axe&lt;/em&gt; they were:  &lt;em&gt;handle, harvest, cutting,  split, tool, wood, battle, chop.&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Police line-up test for word senses:&lt;/strong&gt; the algorithm is given a random one of these 200 polysemous words and a set of $m$ senses which contain the true sense for the word as well as some &lt;em&gt;distractors,&lt;/em&gt; which are randomly picked senses from other words in the testbed. The test taker has to identify the word’s true senses amont these $m$ senses.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;As usual, accuracy is measured using &lt;em&gt;precision&lt;/em&gt; (what fraction of the algorithm/human’s guesses 
were correct) and &lt;em&gt;recall&lt;/em&gt; (how many correct senses were among the guesses).&lt;/p&gt;

&lt;p&gt;For $m=20$ and $k=4$, our algorithm succeeds with precision  $63\%$ and recall $70\%$, and performance remains reasonable for $m=50$. We also administered the test to a group of grad students.
Native English speakers had precision/recall scores in the $75$ to $90$ percent range. 
Non-native speakers had scores roughly similar to our algorithm.&lt;/p&gt;

&lt;p&gt;Our algorithm works something like this: If $w$ is the target word, then take all discourse atoms 
computed for that word, and compute a certain similarity score between each atom and each of the $m$ senses, where the words in the senses are represented by their word vectors. (Details are in the paper.)&lt;/p&gt;

&lt;h2 id=&quot;takeaways&quot;&gt;Takeaways&lt;/h2&gt;

&lt;p&gt;Word embeddings have been useful in a host of other settings, and now it appears that 
they also can easily yield different senses of a polysemous word. We have some subsequent applications of these ideas to other previously studied settings, including topic models, creating 
WordNets for other languages,  and understanding the semantic content of fMRI brain measurements. I’ll describe some of them in future posts.&lt;/p&gt;
</description>
        <pubDate>Sun, 10 Jul 2016 03:30:00 -0700</pubDate>
        <link>http://offconvex.github.io/2016/07/10/embeddingspolysemy/</link>
        <guid isPermaLink="true">http://offconvex.github.io/2016/07/10/embeddingspolysemy/</guid>
      </item>
     
    
     
      <item>
        <title>A Framework for analysing Non-Convex Optimization</title>
        <description>&lt;p&gt;Previously &lt;a href=&quot;http://www.offconvex.org/2016/03/22/saddlepoints/&quot;&gt;Rong’s post&lt;/a&gt; and &lt;a href=&quot;http://www.offconvex.org/2016/03/24/saddles-again/&quot;&gt;Ben’s post&lt;/a&gt; show that (noisy) gradient descent can converge to &lt;em&gt;local&lt;/em&gt; minimum of a non-convex function, and in (large) polynomial time (&lt;a href=&quot;http://arxiv.org/abs/1503.02101&quot;&gt;Ge et al.’15&lt;/a&gt;). This post 
describes a simple framework that can sometimes be used to design/analyse algorithms that can quickly reach an approximate &lt;em&gt;global&lt;/em&gt; optimum of the nonconvex function. The framework —which was used to analyse alternating minimization algorithms for sparse coding  in &lt;a href=&quot;http://arxiv.org/abs/1503.00778&quot;&gt;our COLT’15 paper with Ge and Moitra&lt;/a&gt;—generalizes many other sufficient conditions for convergence (usually gradient-based) that were formulated in recent papers.&lt;/p&gt;

&lt;h2 id=&quot;measuring-progress-a-simple-lyapunov-function&quot;&gt;Measuring progress: a simple Lyapunov function&lt;/h2&gt;

&lt;p&gt;Let $f$ be the function being optimized and suppose the algorithm produces a sequence of candidate solutions $z_1,\dots,z_k,\dots,$ via some update rule
&lt;script type=&quot;math/tex&quot;&gt;z_{k+1} = z_k - \eta g_k.&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;This can be seen as a dynamical system (see &lt;a href=&quot;http://www.offconvex.org/2016/04/04/markov-chains-dynamical-systems/&quot;&gt;Nisheeth’s&lt;/a&gt; and &lt;a href=&quot;http://www.offconvex.org/2016/03/24/saddles-again/&quot;&gt;Ben’s&lt;/a&gt; posts related to dynamical systems).
Our goal is to show that this sequence converges to (or gets close to) a target point $z^* $, which is  a global optimum of $f$. Of course, the algorithm doesn’t know $z^*$.&lt;/p&gt;

&lt;p&gt;To design a framework for proving convergence it helps to indulge in daydreaming/wishful thinking: what property would we &lt;em&gt;like&lt;/em&gt; the updates to have, to simplify our job?&lt;/p&gt;

&lt;p&gt;A natural idea is to define a Lyapunov function $V(z)$ and show that: (i) $V(z_k)$ decreases to $0$ (at a certain speed) as $k\rightarrow \infty$; (ii) when $V(z)$ is close to $0$, then $z$ is close to $z^* $. (Aside: One can imagine more complicated ways of proving convergence, e.g., show $V(z_k)$ ultimately goes to $0$ even though it doesn’t decrease in every step. Nesterov’s acceleration method uses such a progress measure.)&lt;/p&gt;

&lt;p&gt;Consider possibly the most trivial Lyapunov function, the (squared) distance to the target point,  $V(z) = |z-z^*|^2$. This is also used in the standard convergence proof for convex functions, since moving in the opposite direction to the gradient can be shown to reduce this measure $V()$.&lt;/p&gt;

&lt;p&gt;Even when the function is nonconvex, there always &lt;em&gt;exist&lt;/em&gt; update directions that reduce this $V()$ (though finding them may not be easy).  Simple algebraic manipulation shows that when the learning rate $\eta$ is small enough, then for $V(z_{k+1}) \le V(z_k)$, it is necessary and sufficient to have $\langle g_k, z_k-z^* \rangle \ge 0$.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.cs.princeton.edu/~tengyu/angle_for_blog_post.png&quot; alt=&quot;correlation condition&quot; style=&quot;float:left&quot; height=&quot;240.8&quot; width=&quot;260&quot; /&gt; As illustrated in the figure on the left, $z^* - z_k$ is the ideal direction that we desire to move to, and $-g_k$ is the direction that we actually move to. To establish convergence, it suffices to verify that the direction of movement is positively correlated with the desired direction.&lt;/p&gt;

&lt;p&gt;To get quantitative bounds on running time, we need to ensure that $V(z_k)$ not only decreases, but does so rapidly. The next condition formalizes this: intuitively speaking it says that $-g_k$ and $z^*-z_k$ make an angle strictly less than 90 degrees.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Correlation Condition&lt;/strong&gt;: The direction $g_k$ is $(\alpha,\beta,\epsilon_k)$-correlated with $ z^* $  if 
&lt;script type=&quot;math/tex&quot;&gt;\langle g_k,z_k-z^* \rangle \ge \alpha \|z_k-z^*\|^2 + \beta \|g_k\|^2 -\epsilon_k&lt;/script&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This may look familiar to experts in convex optimization: as a special case if we make the update direction $g_k$ stand for the (negative) gradient, then the condition yields familiar notions such as strong convexity and smoothness. But the condition allows $g_k$ to not be the gradient, and in addition, allows  the error term $\epsilon_k$, which is necessary in some applications to accommodate non-convexity and/or statistical error.&lt;/p&gt;

&lt;p&gt;If the algorithm can at each step find such update directions, then the familiar convergence proof of convex optimization can be modified to show rapid convergence here as well, except the convergence is &lt;em&gt;approximate&lt;/em&gt;, to some point in the neighborhood of $z^*$.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Theorem:&lt;/strong&gt; Suppose $g_k$ satisfies the Correlation Condition above for every $k$, then with learning rate $\eta \le 2\beta$, we have 
&lt;script type=&quot;math/tex&quot;&gt;\| z_k-z^* \|^2 \le (1-\alpha\eta)^k\| z_0-z^* \|^2 + \max_k \epsilon_k/\alpha&lt;/script&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;comparison-with-related-conditions&quot;&gt;Comparison with related conditions&lt;/h3&gt;

&lt;p&gt;As mentioned, the “wishful thinking” approach has been used to identify other 
conditions under which specific nonconvex optimizations can be carried out to near-optimality: (&lt;a href=&quot;https://arxiv.org/abs/1212.0467&quot;&gt;JNS’13&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/abs/1312.0925&quot;&gt;Hardt’14&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/abs/1408.2156&quot;&gt;BWY’14&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/abs/1407.1065&quot;&gt;CLS’15&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/abs/1503.00778&quot;&gt;AGMM’15&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/abs/1411.8003&quot;&gt;SL’15&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/abs/1505.05114&quot;&gt;CC’15&lt;/a&gt;, &lt;a href=&quot;https://papers.nips.cc/paper/5733-a-nonconvex-optimization-framework-for-low-rank-matrix-estimation&quot;&gt;ZWL’15&lt;/a&gt;). All of these can be seen as some weakening of convexity (with the exception of the analysis for matrix completion in &lt;a href=&quot;http://arxiv.org/abs/1312.0925&quot;&gt;Hardt’14&lt;/a&gt; which views the updates as noisy power method).&lt;/p&gt;

&lt;p&gt;Our condition appears to contain most if not all of these as special cases.&lt;/p&gt;

&lt;p&gt;Often the update direction $g_k$ in these papers is related to the gradient. For example using the gradient instead of 
$g_k$ in our correlation condition turns it into the “regularity condition” proposed by &lt;a href=&quot;http://arxiv.org/abs/1407.1065&quot;&gt;CLS’15&lt;/a&gt; for analyzing Wirtinger flow algorithm for phase retrieval. 
The gradient stability condition in &lt;a href=&quot;http://arxiv.org/abs/1408.2156&quot;&gt;BWY’14&lt;/a&gt; is also a special case, where $g_k$ is required to be close enough to $\nabla h(z_k)$ for some convex $h$ such that $z^* $ is the optimum of $h$. Then since $\nabla h(z_k)$ has angle &amp;lt; 90 degrees with $z_k-z^*$ (which follows from convexity of $h$), it implies that $g_k$ also does.&lt;/p&gt;

&lt;p&gt;The advantage of our framework is that it encourages one to think of algorithms where $g_k$ is not the gradient.  Thus applying the framework doesn’t require understanding the behavior of the gradient on the entire landscape of the objective function; instead, one needs to understand the update direction (which is  under the algorithm designer’s control) at the 
sequence of points actually encountered while running the algorithm.&lt;/p&gt;

&lt;p&gt;This slight change of perspective may be powerful.&lt;/p&gt;

&lt;h2 id=&quot;application-to-sparse-coding&quot;&gt;Application to Sparse Coding&lt;/h2&gt;

&lt;p&gt;A particularly useful situation for applying the framework above is where the objective function has two sets of arguments and it is feasible to optimize one set after fixing the other –leading to the familiar alternating minimization heuristic. Such algorithms are a good example of how one may try to do local-improvement without explicitly following the (full) gradient. 
As mentioned, our framework was used to analyse
such alternating minimization for &lt;a href=&quot;https://en.wikipedia.org/wiki/Neural_coding#Sparse_coding&quot;&gt;sparse coding&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In sparse coding, we are given a set of examples $Y = [y_1,\dots, y_N]\in \mathbb{R}^{d\times N}$, and are asked to find an over-complete basis $A = [a_1,\dots,a_m]$  (where “overcomplete” refers to the setting
$m &amp;gt; d$) so that each example $y_j$ can be expressed as a sparse linear combination of $a_i$’s. Therefore, the natural optimization problem with squared loss is that&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;f(A,X) = \min_{A, \textrm{sparse } X} \|Y-AX\|^2&lt;/script&gt;

&lt;p&gt;Here both the objective and the constraint set are not convex. 
One could consider using $\ell_1$ regularization as a surrogate for sparsity, but the trouble will be that the regularization is neither smooth or strongly convex, and the standard techniques for dealing with $\ell_1$ penalty term in convex optimization cannot be easily applied due to  non-convexity.&lt;/p&gt;

&lt;p&gt;The standard alternating minimization  algorithm (a close variant of the one proposed by &lt;a href=&quot;http://redwood.psych.cornell.edu/papers/olshausen_field_1997.pdf&quot;&gt;Olshausen and Field 1997&lt;/a&gt; as a neurally plausible explanation for V1, the human primary visual cortex) is as follows:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;X_{k+1} \longleftarrow \textrm{threshold}(A_k^{\top}Y)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;A_{k+1} \longleftarrow A_{k} - \eta \underbrace{\frac{\partial }{\partial A} f(A_k,X_{k+1})}_{G_k}&lt;/script&gt;

&lt;p&gt;Here update for $X$ is the projection pursuit algorithm in sparse recovery (see &lt;a href=&quot;http://www.springer.com/us/book/9781441970107&quot;&gt;Elad’10&lt;/a&gt; for background), which is supposed to give an approximation of the best fit for $X$ given the current $A$.&lt;/p&gt;

&lt;p&gt;Sometimes alternating minimization algorithms need careful initialization, but in practice here it suffices to initialize $A_0$ using a random sample of datapoints $y_i$’s.&lt;/p&gt;

&lt;p&gt;However, it remains an open problem to analyse convergence using such random initialization; our analysis uses a special starting point $A_0$ found using spectral methods.&lt;/p&gt;

&lt;h3 id=&quot;applying-our-framework&quot;&gt;Applying our framework&lt;/h3&gt;

&lt;p&gt;At first glance, the mysterious aspect of our framework was how the algorithm can find an update direction correlating with $z_k -z^* $,  without knowing $z^* $? In context of sparse coding, this comes about as follows:  if we assume a probabilistic generative model for the observed data (namely, it was generated using some ground-truth sparse coding) then the alternating minimization automatically comes up with such  update directions!&lt;/p&gt;

&lt;p&gt;Specifically, we will assume that the data points $y_i$’s are generated using some ground truth dictionary $A^* $ 
 using some ground truth $X^* $ whose columns are iid draws from some suitable distribution.
 (One needs to assume some conditions on $A^* , X^* $, which  are not important in the sketch below.)  Note that the 
 entries within each column of $X^* $  are &lt;em&gt;not&lt;/em&gt; mutually independent, otherwise the problem would be &lt;a href=&quot;https://en.wikipedia.org/wiki/Independent_component_analysis&quot;&gt;Independent Component Analysis&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In line with our framework, we consider the Lyapunov function $V(A) = |A-A^* |_F^2$. Here the Frobenius norm $|\cdot|_F$ is also the Euclidean norm of the vectorized version of the matrix. Then our framework implies that to show quick convergence it suffices to verify the following (for some $\alpha,\beta &amp;gt; 0$)	 for the update direction $G_k$:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\langle G_k, A_k-A^* \rangle \ge \alpha \|A_k - A^* \|_F^2 + \beta \|G_k\|_F^2 -\epsilon_k&lt;/script&gt;

&lt;p&gt;In &lt;a href=&quot;http://arxiv.org/abs/1503.00778&quot;&gt;AGMM’15&lt;/a&gt; we showed that under certain assumption on the true dictionary $A^* $ and the true coefficient $X^* $, the above inequality is indeed true with small $\epsilon_k$ and some constant $\alpha,\beta &amp;gt; 0$. The proof is a bit technical but reasonable — the partial gradient $\frac{\partial f}{\partial A}$ has a simple form and therefore $G_k$ has a closed form in $A_k$ and $Y$. Therefore, it boils down to plugging in the form of $G_k$ into the equation above and simplifying it appropriately.  (One also needs the fact that
the starting $A_0$ obtained using spectral methods is somewhat close to $A^* $.)&lt;/p&gt;

&lt;p&gt;We hope others will use our framework to analyse other nonconvex problems!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(Aside: We hope that readers will leave comments if they know of other frameworks for proving convergence that are not subcases of the above framework.)&lt;/em&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 08 May 2016 02:00:00 -0700</pubDate>
        <link>http://offconvex.github.io/2016/05/08/almostconvexitySATM/</link>
        <guid isPermaLink="true">http://offconvex.github.io/2016/05/08/almostconvexitySATM/</guid>
      </item>
     
    
  </channel>
</rss>
